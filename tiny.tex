\documentclass[10pt]{article}
\usepackage{fullpage}

\thickmuskip=5mu plus 3mu minus 1mu
\medmuskip=4mu plus 2mu minus 3mu

% \usepackage{scohesion}

\usepackage{amssymb,amsthm}
\usepackage{thmtools}
\usepackage{amsmath}
\usepackage{stmaryrd}
\usepackage{wasysym}

\usepackage{mathpartir}
\usepackage{tikz-cd}

\usepackage{graphicx}
\usepackage{scalerel}
\usepackage{fontawesome}

\usepackage{xcolor}
\definecolor{darkgreen}{rgb}{0,0.45,0}

\usepackage[status=draft,inline,nomargin]{fixme}
\FXRegisterAuthor{mvr}{anmvr}{\color{blue}MVR}

\usepackage[style=alphabetic, maxbibnames=99, maxalphanames=99,
mincrossrefs=99]{biblatex}
\addbibresource{tiny.bib}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{example}[theorem]{Example}
\newtheorem{question}{Question}

\let\oldequiv\equiv%
\renewcommand{\equiv}{\simeq}
\newcommand{\defeq}{\oldequiv}
\newcommand{\ndefeq}{\not\defeq}

\newcommand{\rulen}[1]{\textsc{#1}}
\newcommand{\yields}{\vdash}
\newcommand{\qyields}{\Vdash}
\newcommand{\cbar}{\, | \,}
\newcommand{\judge}{\mathcal{J}}
\newcommand{\freshfor}{\mathbin{\#}}

\newcommand{\ctx}{\,\,\mathsf{ctx}}
\newcommand{\type}{\,\,\mathsf{type}}
\newcommand{\tele}{\,\,\mathsf{tele}}

% Ordinary HoTT notation
\newcommand{\Idsym}{\mathsf{Id}}
\newcommand{\Id}{\mathsf{Id}}
% \newcommand{\Id}[3]{\mathsf{Id}_{{#1}}(#2,#3)}
\newcommand*{\trunc}[2]{\mathopen{}\left\Vert #2\right\Vert_{#1}\mathclose{}}
\newcommand*{\strunc}[2]{\mathopen{}\left\Vert #2\right\Vert_{#1}^s\mathclose{}}
\newcommand*{\univ}{\mathcal{U}}
\newcommand*{\NN}{\mathbb{N}}
\newcommand*{\ZZ}{\mathbb{Z}}
% \newcommand*{\true}{\star}
\newcommand*{\id}{\mathsf{id}}
\newcommand*{\proj}{\mathsf{pr}}
\newcommand*{\pushpr}{\mathbin{\wasysquare}}
\newcommand*{\join}{\ast}
\newcommand*{\ap}{\mathsf{ap}}
\newcommand*{\transp}{\mathsf{tr}}
\newcommand*{\isContr}{\mathsf{isContr}}
\newcommand*{\isEquiv}{\mathsf{isEquiv}}
\newcommand*{\isSpace}{\mathsf{isSpace}}
\newcommand*{\isModal}{\mathsf{isModal}}
\newcommand*{\inl}{\mathsf{inl}}
\newcommand*{\inr}{\mathsf{inr}}
\newcommand*{\glue}{\mathsf{glue}}
\newcommand*{\code}{\mathsf{code}}
\newcommand*{\encode}{\mathsf{encode}}
\newcommand*{\decode}{\mathsf{decode}}
\newcommand*{\const}{\mathsf{const}}
\newcommand*{\fib}{\mathsf{fib}}
\newcommand*{\case}{\mathsf{case}}
\newcommand*{\refl}[1]{\mathsf{refl}_{#1}}
\newcommand*{\pathind}[3]{\mathsf{let} \; \refl{#2} = {#1} \,
  \mathsf{in} \, {#3}}
\newcommand*{\cupann}[2]{\mathbin{\tensor*[_{#1}]{\cup}{_{#2}}}}
\newcommand{\bang}{\mathord{!}}
\newcommand{\ind}[3]{\mathsf{let} \; {#2} = {#1} \, \mathsf{in} \, {#3}}

% \makeatletter
% \newcommand{\@thesum}[1]{(#1) \times}
% \newcommand{\sm}[1]{\@ifnextchar\bgroup{\@thesum{#1}\sm}{\@thesum{#1}}}
% \newcommand{\@theprd}[1]{(#1) \to}
% \newcommand{\prd}[1]{\@ifnextchar\bgroup{\@theprd{#1}\prd}{\@theprd{#1}}}
% \makeatother

\makeatletter \def\smsym{\sum}
\newcommand{\@thesum}[1]{\smsym_{(#1)}}
\newcommand{\sm}[1]{\@ifnextchar\bgroup{\@sm{#1}\sm}{\@sm{#1}}}
\newcommand{\@sm}[1]{\mathchoice{{\textstyle\@thesum{#1}}}{\@thesum{#1}}{\@thesum{#1}}{\@thesum{#1}}}
\def\prdsym{\prod}
\newcommand{\@theprd}[1]{\prdsym_{(#1)}}
\newcommand{\prd}[1]{\@ifnextchar\bgroup{\@prd{#1}\prd}{\@prd{#1}}}
\newcommand{\@prd}[1]{\mathchoice{{\textstyle\@theprd{#1}}}{\@theprd{#1}}{\@theprd{#1}}{\@theprd{#1}}}
\makeatother

\newcommand*{\lolli}{\multimap}

% \newcommand{\lock}{\text{\faLock}}
\newcommand{\lock}{\mathchoice {\scalebox{0.8}{\text{\faLock}}}
  {\scalebox{0.8}{\text{\faLock}}} {\scalebox{0.5}{\text{\faLock}}}
  {\scalebox{0.4}{\text{\faLock}}} }
\newcommand{\unlock}{\text{\faUnlock}}
\newcommand{\key}{\mathchoice
  {\scalebox{0.8}{\text{\faKey}}} {\scalebox{0.8}{\text{\faKey}}}
  {\scalebox{0.5}{\text{\faKey}}} {\scalebox{0.4}{\text{\faKey}}} }

\newcommand{\rbindsym}{\raisebox{-0.5pt}{\scalerel*{\reflectbox{\rotatebox[origin=c]{185}{$\lambda$}}}{\lambda}}}
\newcommand{\rbind}[1]{\rbindsym{} #1.}
% lol
% \newcommand{\rbind}[1]{. #1 \rbindsym{}}

\newcommand{\Tiny}{\mathbb{T}}
\newcommand{\lockn}[1]{\mathcal{#1}}
\newcommand{\locksin}[1]{\mathsf{locks}(#1)}
\newcommand{\varkeye}[2]{\key_{#1}^{#2}}
\newcommand{\varkey}[2]{\varkeye{\lockn{#1}}{#2}}
\newcommand{\admkeye}[2]{\overrightarrow{\key}_{#1}^{#2}}
\newcommand{\admkey}[2]{\admkeye{\lockn{#1}}{#2}}
\newcommand{\ctxlocke}[1]{\lock_{#1}}
\newcommand{\ctxlock}[1]{\ctxlocke{\lockn{#1}}}
% \newcommand{\ctxopen}[2]{\unlock_{\lockn{#1}}^{\,#2}}
\newcommand{\stubra}[1]{\llbracket #1 \rrbracket}
% \newcommand{\stubra}[1]{\lfloor #1 \rfloor}
\newcommand{\admbra}[1]{[ #1 ]}
\newcommand{\subkeye}[2]{\admbra{#1/\key_{#2}}}
\newcommand{\subkey}[2]{\subkeye{#1}{\lockn{#2}}}
\newcommand{\substucke}[2]{\stubra{#1/\key_{#2}}}
\newcommand{\substuck}[2]{\substucke{#1}{\lockn{#2}}}
% \newcommand{\sublock}[2]{\admbra{\lock_{\lockn{#1}}/#2}}
\newcommand{\sublock}[2]{\admbra{\rbindsym{} #2. /\lock_{\lockn{#1}} }}
% \newcommand{\sublock}[2]{\admbra{ .#2 \rbindsym{} /\lock_{\lockn{#1}} }}

\newcommand{\rformsym}{\surd}
\newcommand{\rforme}[2]{\ThisStyle{\raisebox{0.07em}{$\SavedStyle \surd_{\hspace{-0.25em}#1}$}} #2}
\newcommand{\rform}[2]{\rforme{\lockn{#1}}{#2}}
\newcommand{\rformu}[1]{\ThisStyle{\raisebox{0.07em}{$\SavedStyle \surd$}} #1}
% \newcommand{\rintroe}[2]{\mathsf{root}_{#1}(#2)}
\newcommand{\rintroe}[2]{\lock_{#1}. #2}
\newcommand{\rintro}[2]{\rintroe{\lockn{#1}}{#2}}
% \newcommand{\relim}[1]{\mathsf{unroot}(#1)}
% \newcommand{\rbindsym}{\rotatebox[origin=c]{180}{$\lambda$}}

\newcommand{\relim}[1]{\rbindsym #1}
\newcommand{\retro}[1]{\mathsf{retro}\,#1}

% \newcommand{\rdepform}[2]{{\between^{#1}}#2}
\newcommand{\rdepform}[2]{{#2}^{1/#1}}

\newcommand{\rget}[1]{{#1}_{\downharpoonleft}}

\usepackage{hyperref}
\usepackage{cleveref}
\hypersetup{colorlinks,citecolor=darkgreen,linkcolor=darkgreen}

\title{Tiny Object}
\author{}
\date{}

\begin{document}
\maketitle

We describe a type theory that makes a fixed type $\Tiny$ a `tiny
object': there is a type former $\rformu$ that is the amazing right
adjoint to $(\Tiny \to -)$. Of necessity this is an \emph{external}
right adjoint, and so the context structure of ordinary type theory
will have to be modified to support it.

We add $\rformu$ as a `Fitch style'
modality~\cite{clouston:fitch-style}, where the type former $\rformu$
is made right-adjoint to a context lock. Such modalities are
particularly nice when they are a \emph{double} right adjoint, and
FitchTT~\cite{fitchtt} investigates adding modalities of this kind to
MLTT. We are in such a situation, of course, because
\[{(- \times \Tiny) \dashv (\Tiny \to -) \dashv \rformu -},\] and so
we could use~\cite{fitchtt} directly to produce a type theory.

But there is a special feature of $\rformu$ which impels us to create
a specialised theory for it. Specifically, the leftmost adjoint
$(- \times \Tiny)$ already exists as an operation on contexts: it is
simply context extension with $i : \Tiny$. We allow $\Tiny$ to be an
\emph{ordinary type}, rather than a pre-type or special piece of
syntax. The only new context former needed is something corresponding
to $(\Tiny \to -)$, which we write as $\lock$.

To make $(-,i:\Tiny) \dashv (-,\lock)$ on contexts, we need unit
$\Gamma \to (\Gamma,i : \Tiny, \lock)$ and counit
$(\Gamma,\lock,i : \Tiny) \to \Gamma$
substitutions. In~\cite{fitchtt}, these are added axiomatically, and
the type theory is presented in a variable-free CwF style where these
explicit substitutions are pushed around manually. The downside of the
approach is that figuring out how to use a variable could be
challenging: we may have to devise by hand a complicated explicit
substitution that extracts the variable from the context. It is
expected that FitchTT satisfies strong normalisation, and so there is
a set of normal forms for variable uses, but this does not assist a
user of the type theory in writing one down.  One of our aims is to
give a fully explicit variable rule, which builds the in normal forms
of these `stuck substitutions'.

The reason this gets interesting is that, because $\Tiny$ is an
ordinary type, we can substitute \emph{any term} $t : \Tiny$ for $i$
in the counit substitution. And so, the admissible counit rule is
parameterised by a genuine term $t : \Tiny$. The counit rule only gets
stuck on the ordinary variable rule, so every use of a variable in
this theory can have (possibly many) attached terms of $\Tiny$
corresponding to these stuck counits. Having $\Tiny$ as an ordinary
type contrasts with
\cite{cavallo-harper:parametricity-for-ctt,cavallo:thesis} and
\cite[Section 5]{fitchtt}, where the $\Gamma,i:\Tiny$ context
extension is a special piece of syntax, and so only special `terms'
may be substituted for it.

In contrast to \cite[Section 2]{transpension}, we only add a right
adjoint for the non-dependent function space, rather than adding a
right adjoint to the dependent product
$\Pi_\Tiny : \mathcal{E}/\Tiny \to \mathcal{E}$. This makes the rules
for the $\rformu$ type much simpler, and (conjecturally) lets us
maintain admissibility of substitution, normalisation, etc. And, maybe
surprisingly, a right adjoint to the dependent function space is
derivable from our simply-typed version.

In~\cite{lops}, a tiny interval $\mathbb{I}$ is used to internally
construct a universe that classifies fibrations. The $\rformu$ type
former is described by a collection of axioms, and the fact that the
adjunction is external is enforced by requiring the inputs to these
axioms to be `crisp', roughly, protected by a use of the global
sections/discrete inclusion modality $\flat$. The result is an
equivalence
$\flat((\Tiny \to A) \to B) \equiv \flat(A \to \rformu B)$, but we
will see that this is more restrictive than necessary. If we have the
$\rformu$ type former built-in, then we can prove an equivalence
$\rformu ((\Tiny \to A) \to B) \equiv (A \to \rformu B)$, where $A$
and $B$ do not have to be `global types'. (But the dependency of $B$
is still somewhat restricted.)

Our type theory tackles a challenge set by Lawvere, to produce a
formal system for working with tiny objects: ``This possibility does
not seem to have been contemplated by combinatory logic; the formalism
should be extended to enable treatment of so basic a
situation''~\cite[Section 3]{lawvere:adjoints}.

% \mvrnote{Which cube categories have tiny intervals?
% \cite{buchholtz-morehouse:cubes}}

\section{Contexts and Variables}

The $\rformu$ type former will be added by making it right-adjoint to
a judgemental version of ``$\Tiny \to \Gamma$'', which we write as
$\Gamma, \ctxlock{L}$. This first section will be spent adding the
necessary rules for $\Gamma, \ctxlock{L}$ to behave like functions
into $\Gamma$. These rules are completely structural, independent of
any rules for types (besides the existence of a type $\Tiny$).

There are two new base rules, the context lock and the modified
variable rule. There are two new admissible rules, corresponding to
precomposition with the counit and unit of the
$(-,i:\Tiny) \dashv (-,\lock)$ adjunction.

\begin{itemize}
\item \textbf{The Tiny Type.} There is a closed type $\Tiny$.
  \begin{mathpar}
    \inferrule*[left=tiny-form]{\Gamma \ctx}{\Gamma \yields \Tiny \type}
  \end{mathpar}

\item \textbf{Context Lock.} There is a special context extension,
  \begin{mathpar}
    \inferrule*[left=ctx-lock]{\Gamma \ctx}{\Gamma, \ctxlock{L} \ctx}
    \and
  \end{mathpar}
  to be thought of as $\Tiny \to \Gamma$. We call $\lockn{L}$ a `lock
  name', all lock names in a context are unique.

\item \textbf{Counit.} Because a lock on a context is just a function
  into that context, we can use variables to the left of a lock if we
  can provide an argument to the function: this corresponds to the
  counit $(\Gamma, \ctxlock{L}, i : \Tiny) \to \Gamma$ of the
  $(- \times \Tiny) \dashv (\Tiny \to -)$ adjunction, with some
  precomposition and contraction built in. The simplest situation we
  can encounter is
  \begin{mathpar}
    \inferrule*[left=counit?,fraction={-{\,-\,}-}]{\Gamma \yields a :
      A \and \Gamma, \ctxlock{L}, \Gamma' \yields t : \Tiny \and \lock
      \notin \Gamma'}{\Gamma, \ctxlock{L}, \Gamma' \yields
      a\subkey{t}{L} : A\subkey{t}{L}}
  \end{mathpar}
  corresponding to the composite
  \begin{align*}
    (\Tiny \to \Gamma) \times \Gamma'
    \xrightarrow{[\id, t]} (\Tiny \to \Gamma) \times \Gamma' \times
    \Tiny
    \xrightarrow{\proj} (\Tiny \to \Gamma) \times \Tiny
    \xrightarrow{\varepsilon} \Gamma
    \xrightarrow{a} A
  \end{align*}

  The new piece of term syntax is a stuck instance of this
  $\subkey{t}{L}$ rule, which we build into the variable rule
  below. To distinguish the admissible rule from the stuck rule, we
  will write the admissible rule as $\subkey{t}{L}$ and the actual
  stuck syntax as $\substuck{t}{L}$. Roughly, the admissible
  $\subkey{t}{L}$ will add a $\substuck{t}{L}$ to every
  \emph{free} variable usage in $a$, a bit like the underlining operation in
  the type theory for $\natural$.

  We will need a generalised version of this counit rule, for going
  under binders in the term $a : A$. The actual counit rule is then
  \begin{mathpar}
    \inferrule*[left=counit,fraction={-{\,-\,}-}]{\Gamma, \Gamma''
      \yields a : A \and \Gamma, \ctxlock{L}, \Gamma' \yields t :
      \Tiny}{\Gamma, \ctxlock{L}, \Gamma', \Gamma'' \subkey{t}{L}
      \yields a \subkey{t}{L} : A \subkey{t}{L} }
  \end{mathpar}

\item \textbf{Variable Usage.} To use a variable $x : A$ that is
  behind some context locks, we have to provide a term $t_i : \Tiny$
  for each lock between that variable and the front of the context.

  Suppose that in the context $\Gamma, x : A, \Gamma'$, the telescope
  $\Gamma'$ contains the locks
  $\ctxlocke{\lockn{L}_1}, \dots, \ctxlocke{\lockn{L}_n}$ from left to
  right; we write this (ordered) list as $\locksin{\Gamma'}$.
  \begin{mathpar}
    \inferrule*[left=var]
    {\Gamma, x : A, \Gamma' \yields t_i : \Tiny
      \text{ for } \lockn{L}_i \in \locksin{\Gamma'} }
    {\Gamma, x : A, \Gamma' \yields x \substucke{t_1}{\lockn{L}_1}
      \dots \substucke{t_n}{\lockn{L}_n} :
      A \subkeye{t_1}{\lockn{L}_1} \dots \subkeye{t_n}{\lockn{L}_n}}
  \end{mathpar}
  This is all one term, though we write the stuck counits using
  separate brackets.

  The type of the variable usage has the admissible counit rule
  applied to it: typically these counits will not be stuck on the type
  $A$ unless $A$ is itself a variable.

\item \textbf{Calculating the Counit.}  On a general term $b : B$, the
  operation $b\subkey{t}{L}$ is calculated as follows.  Starting with
  a term $\Gamma \yields b : B$, we induct on $b$ until we reach an
  instance of the variable rule, say for then variable $x : A$.

  We first dispense with the easy case. Suppose the variable is in
  $\Gamma''$, so
  \begin{align*}
    \Gamma, \Gamma_1'', x : A, \Gamma_2'' &\ctx \\
    \locksin{\Gamma_2''} &\defeq \lockn{K}_{1}, \dots, \lockn{K}_n
  \end{align*}
  and the variable usage looks like
  \begin{align*}
    \Gamma, \Gamma_1'', x : A, \Gamma_2''
    &\yields x \substucke{s_1}{\lockn{K}_1} \dots \substucke{s_n}{\lockn{K}_n} \\
    &: A\subkeye{s_1}{\lockn{K}_1} \dots \subkeye{s_n}{\lockn{K}_n}
  \end{align*}
  Then access to $x$ is not affected by the addition of the lock
  $\ctxlock{L}$, so we can reapply the variable rule. The terms $s_i$
  used on the other keys, however, may themselves use variables from
  $\Gamma$. These variables lie behind the new lock $\ctxlock{L}$, so
  we must proceed with applying the same \rulen{counit} to the $s_i$:
  \begin{align*}
    \Gamma, \ctxlock{L}, \Gamma', \Gamma_1'', x : A, \Gamma_2''
    &\yields x \substucke{s_1\subkey{t}{L}}{\lockn{K}_1} \dots \substucke{s_n\subkey{t}{L}}{\lockn{K}_n} \\
    &: A\subkeye{s_1\subkey{t}{L}}{\lockn{K}_1} \dots \subkeye{s_n\subkey{t}{L}}{\lockn{K}_n}
  \end{align*}

  Now for the difficult case, when $x : A$ is in $\Gamma$. For now,
  say that all the terms of $\Tiny$ that are involved are closed.
  Suppose the context has the form
  \begin{align*}
    \Gamma_1, x : A, \Gamma_2, \Gamma'' &\ctx \\
    \locksin{\Gamma_2} &\defeq \lockn{K}_1, \dots,\lockn{K}_i \\
    \locksin{\Gamma''} &\defeq \lockn{K}_{i+1}, \dots, \lockn{K}_n
  \end{align*}
  so that the variable usage looks like
  \begin{align*}
    \Gamma_1, x : A, \Gamma_2, \Gamma''
    &\yields x \substucke{s_1}{\lockn{K}_1} \dots
      \substucke{s_{i}}{\lockn{K}_{i}}
      \substucke{s_{i+1}}{\lockn{K}_{i+1}}
      \dots \substucke{s_n}{\lockn{K}_n} \\
    &: A\subkeye{s_1}{\lockn{K}_1} \dots
      \subkeye{s_{i}}{\lockn{K}_{i}}
      \subkeye{s_{i+1}}{\lockn{K}_{i+1}}
      \dots \subkeye{s_n}{\lockn{K}_n}
  \end{align*}
  Then we slot the new $\subkey{t}{L}$ into place:
  \begin{align*}
    \Gamma_1, x : A, \Gamma_2, \ctxlock{L}, \Gamma'' \yields
    (&x \substucke{s_1}{\lockn{K}_1} \dots
    \substucke{s_{i}}{\lockn{K}_{i}} \substucke{s_{i+1}}{\lockn{K}_{i+1}}
    \dots \substucke{s_n}{\lockn{K}_n}) \subkey{t}{L} \\
    :\defeq {}
    &x \substucke{s_1}{\lockn{K}_1} \dots
    \substucke{s_{i}}{\lockn{K}_{i}} \substuck{t}{L} \substucke{s_{i+1}}{\lockn{K}_{i+1}}
    \dots \substucke{s_n}{\lockn{K}_n}
  \end{align*}

  Working informally, this means counting how many
  $\ctxlocke{\lockn{K}_i}$ are created between the application of
  $\subkey{t}{L}$ and the variable (by the use of some of the typing
  rules), and placing $\subkey{t}{L}$ to the left of all the newly
  created $\ctxlocke{\lockn{K}_i}$.

  When $t : \Tiny$ is not closed, so that
  $\Gamma_1, x : A, \Gamma_2, \ctxlock{L}, \Gamma' \yields t : \Tiny$,
  the variables used in the term $t$ itself are now locked behind the
  locks in $\Gamma''$, by the time we reach the variable $x$. We
  therefore need to (admissibly) apply
  \begin{align*}
    \subkeye{s_{i+1}}{\lockn{K}_{i+1}} \dots \subkeye{s_{n}}{\lockn{K}_{n}}
  \end{align*}
  to the term $t$, so:
  \begin{align*}
    &x \substucke{s_1}{\lockn{K}_1} \dots
    \substucke{s_{i}}{\lockn{K}_{i}} \substucke{s_{i+1}}{\lockn{K}_{i+1}}
    \dots \substucke{s_n}{\lockn{K}_n} \subkey{t}{L} \\
    :\defeq {}
    &x \substucke{s_1}{\lockn{K}_1} \dots
    \substucke{s_{i}}{\lockn{K}_{i}} \substucke{(t\subkeye{s_{i+1}}{\lockn{K}_{i+1}}
    \dots \substucke{s_n}{\lockn{K}_n})}{L} \substucke{s_{i+1}}{\lockn{K}_{i+1}}
    \dots \substucke{s_n}{\lockn{K}_n}
  \end{align*}


  Instead, say that the terms $s_i$ used on the other keys are not
  closed, and so the variables used in them might now lie behind the
  new lock $\ctxlock{L}$. The term $t$ is used to unlock them:
  \begin{alignat*}{2}
    &x &&\substucke{s_1}{\lockn{K}_1} \dots
    \substucke{s_{i}}{\lockn{K}_{i}} \substucke{s_{i+1}}{\lockn{K}_{i+1}}
    \dots \substucke{s_n}{\lockn{K}_n} \subkey{t}{L} \\
    :\defeq {}
    &x
    &&\substucke{s_1\subkey{t}{L}}{\lockn{K}_1} \\
    &&& \dots \\
    &&& \substucke{s_{i}\subkey{t}{L}}{\lockn{K}_{i}} \\
    &&& \substuck{t}{L} \\
    &&& \substucke{s_{i+1}\subkey{t}{L}}{\lockn{K}_{i+1}} \\
    &&& \dots \\
    &&& \substucke{s_n\subkey{t}{L}}{\lockn{K}_n}
  \end{alignat*}

  Finally, and slightly horrifyingly, the two complications can happen
  at the same time, yielding our actual definition:
  \begin{alignat*}{2}
    &x &&\substucke{s_1}{\lockn{K}_1} \dots
    \substucke{s_{i}}{\lockn{K}_{i}} \substucke{s_{i+1}}{\lockn{K}_{i+1}}
    \dots \substucke{s_n}{\lockn{K}_n} \subkey{t}{L} \\
    :\defeq {}
    &x
    &&\substucke{s_1\subkey{t}{L}}{\lockn{K}_1} \\
    &&& \dots \\
    &&& \substucke{s_{i}\subkey{t}{L}}{\lockn{K}_{i}} \\
    &&& \substuck{t\subkeye{s_{i+1}\subkey{t}{L}}{\lockn{K}_{i+1}} \dots \subkeye{s_n\subkey{t}{L}}{\lockn{K}_n}}{L} \\
    &&& \substucke{s_{i+1}\subkey{t}{L}}{\lockn{K}_{i+1}} \\
    &&& \dots \\
    &&& \substucke{s_n\subkey{t}{L}}{\lockn{K}_n}
  \end{alignat*}

  \mvrnote{It's not so obvious to me that this terminates!}
  % (The collective size of the terms $s_n, \dots, s_{i+1}, t$ is
  % smaller than the size of $t$ and $b$, so this process eventually
  % terminates.)

  \begin{mathpar}
    \inferrule*
    {\Gamma_1, x : A, \Gamma_2, \ctxlock{L}, \Gamma' \yields t :
      \Tiny \and
      \inferrule*
      {\Gamma_1, x : A, \Gamma_2, \Gamma', \Gamma_1'', \ctxlock{K}, \Gamma_2'' \yields s : \Tiny \and
        \Gamma_1, x : A, \Gamma_2, \ctxlock{L}, \Gamma' \yields t : \Tiny
      }
      {\Gamma_1, x : A, \Gamma_2, \ctxlock{L}, \Gamma', \Gamma_1''\subkey{t}{L}, \ctxlock{K}, \Gamma_2''\subkey{t}{L} \yields s\subkey{t}{L} : \Tiny}
    }
    {\Gamma_1, x : A, \Gamma_2, \ctxlock{L}, \Gamma', \Gamma_1''\subkey{t}{L}, \ctxlock{K}, \Gamma_2'' \subkey{t}{L} \yields t\subkey{s\subkey{t}{L}}{K} : \Tiny}
  \end{mathpar}

\item \textbf{Substitution.} Ordinary substitution into a variable turns these
  `stuck' counits back into admissible ones.
  \begin{align*}
    % \Gamma, x : A, \Gamma'
    % &\yields x \substucke{t_1}{\lockn{L}_1} \dots
    %   \substucke{t_n}{\lockn{L}_n} : A\subkeye{t_1}{\lockn{L}_1} \dots \subkeye{t_n}{\lockn{L}_n} \\
    \Gamma, \Gamma'[a/x]
    &\yields (x \substucke{t_1}{\lockn{L}_1} \dots
      \substucke{t_n}{\lockn{L}_n})[a/x] \\
    &:\defeq a\subkeye{t_1}{\lockn{L}_1} \dots
      \subkeye{t_n}{\lockn{L}_n} : A\subkeye{t_1}{\lockn{L}_1} \dots \subkeye{t_n}{\lockn{L}_n}
  \end{align*}

\item \textbf{Unit.} To complete the implementation of the adjunction,
  we have an admissible rule representing the unit map. The following
  rule is precomposition with the substitution
  $\Gamma \to (\Gamma,i : \Tiny, \ctxlock{L})$, suitably generalised
  with a telescope $\Gamma'$:
  \begin{mathpar}
    \inferrule*[left=unit,fraction={-{\,-\,}-}]
    {\Gamma, i : \Tiny, \ctxlock{L}, \Gamma' \yields a : A}
    {\Gamma, \Gamma'\sublock{L}{i} \yields a\sublock{L}{i} : A\sublock{L}{i}}
  \end{mathpar}
  Like the $\subkey{t}{L}$ operation, we use substitution-like syntax
  for the unit map because it commutes past everything until it
  reaches a variable. The silly $\rbind{i}$ notation is used to
  match the syntax for the type former later, sorry!

  The lock and key then `click together', yielding an ordinary
  substitution. In the simplest case, when $t : \Tiny$ is closed and
  $x$ has a single stuck instance of \rulen{counit}:
  \begin{align*}
    x \substuck{t}{L}\sublock{L}{i}
    :\defeq x[t/i]
  \end{align*}

  If $x$ has additional stuck keys, the operation needs to continue
  into these stuck keys. To avoid complications involved in defining
  an $n$-ary version of the \rulen{counit} admissible rule, we
  immediately divide into cases on whether the variable is the one
  being `substituted' for by the \rulen{unit} rule.
  \begin{align*}
    &i \substucke{s_1}{\lockn{K}_1} \dots
    \substucke{s_{i}}{\lockn{K}_{i}} \substuck{t}{L} \substucke{s_{i+1}}{\lockn{K}_{i+1}}
    \dots \substucke{s_n}{\lockn{K}_n}\sublock{L}{i} \\
    :\defeq {}
    &t\sublock{L}{i} \\
    &x \substucke{s_1}{\lockn{K}_1} \dots
    \substucke{s_{i}}{\lockn{K}_{i}} \substuck{t}{L} \substucke{s_{i+1}}{\lockn{K}_{i+1}},
    \dots \substucke{s_n}{\lockn{K}_n}\sublock{L}{i} \\
    :\defeq {}
    &x\substucke{s_1\sublock{L}{i}}{\lockn{K}_1} \dots
    \substucke{s_{i}\sublock{L}{i}}{\lockn{K}_{i}} \substucke{s_{i+1}\sublock{L}{i}}{\lockn{K}_{i+1}}
    \dots \substucke{s_n\sublock{L}{i}}{\lockn{K}_n}
  \end{align*}
  % \begin{align*}
  %   &x \stubra{\subkeye{s_1}{\lockn{K}_1}, \dots,
  %   \subkeye{s_{i}}{\lockn{K}_{i}}, \subkey{t}{L}, \subkeye{s_{i+1}}{\lockn{K}_{i+1}},
  %   \dots, \subkeye{s_n}{\lockn{K}_n}}\sublock{L}{i} \\
  %   :\defeq {}
  %   &x[t\sublock{L}{i}/i]\admbra{\subkeye{s_1\sublock{L}{i}}{\lockn{K}_1}, \dots,
  %   \subkeye{s_{i}\sublock{L}{i}}{\lockn{K}_{i}}, \subkeye{s_{i+1}\sublock{L}{i}}{\lockn{K}_{i+1}},
  %   \dots, \subkeye{s_n\sublock{L}{i}}{\lockn{K}_n}}
  % \end{align*}

  % \begin{align*}
  %   (\varkey{L'}{t'} \varkeye{\lockn{K}_n}{s_n} \dots \varkeye{\lockn{K}_1}{s_1} x)[\sublock{L}{i}] &:\defeq \admkey{L'}{t'[\sublock{L}{i}]}(\varkeye{\lockn{K}_n}{s_n} \dots \varkeye{\lockn{K}_1}{s_1} x)[\sublock{L}{i}] \\
  %   (\varkey{L}{t} \varkeye{\lockn{K}_n}{s_n} \dots \varkeye{\lockn{K}_1}{s_1} x)[\sublock{L}{i}] &:\defeq (\varkeye{\lockn{K}_n}{s_n} \dots \varkeye{\lockn{K}_1}{s_1} x)[t[\sublock{L}{i}]/i] \\
  %   x[\sublock{L}{i}] &:\defeq x
  %   % (\admkey{L}{t} c) [a/x] &:\defeq \admkey{L}{t[a/x]} c[a/x] \\
  %   % (\varkey{L}{t} c)[\sublock{L}{i}] &:\defeq c[t[\sublock{L}{i}]/i] %\\
  %   % (\admkey{K}{t} c)[\sublock{L}{i}] &:\defeq
  %   % \admkey{K}{t[\sublock{L}{i}]} c[\sublock{L}{i}] &&\lockn{L}
  %   % \not\defeq \lockn{K}
  % \end{align*}

  Both the lock $\lockn{L}$ and the variable $i$ no longer appear in
  the resulting term $a\sublock{L}{i}$.
\end{itemize}

\begin{remark}
  To be careful, we should have proper calculus of telescopes
  $\Gamma \yields \Gamma' \tele$ that $-\subkey{t}{L}$
  and $-\sublock{L}{i}$ are defined on.
\end{remark}

\begin{remark}
  We do not have weakening by additional locks for arbitrary terms,
  but we do have a kind of lock weakening for closed terms:
  \begin{mathpar}
    \inferrule*[left=closed-lock-wk,fraction={-{\,-\,}-}]
    {\Gamma \yields \judge}
    {\ctxlock{L}, \Gamma \yields \judge}
  \end{mathpar}
\end{remark}

These rules are all peculiar, but if we insist on pushing the
admissible rules to the leaves they are forced on us by the setting we
are trying to capture.

\subsection{Examples of Admissible Rules}

Some examples of applying keys to terms:
\begin{alignat*}{2}
  &x : \NN,  y : \NN
  &&\yields x + y : \NN \\
  &x : \NN,  y : \NN, \ctxlock{L}, i : \Tiny
  &&\yields (x + y)\subkey{i}{L} : \NN\subkey{i}{L} \\
  &&&\defeq x\substuck{i}{L} + y\substuck{i}{L} : \NN \\
  ~\\
  &x : \NN
  &&\yields (\lambda y. x + y) : \NN \to \NN  \\
  &x : \NN,\ctxlock{L}, i : \Tiny
  &&\yields (\lambda y. x + y)\subkey{i}{L} : (\NN \to \NN)\subkey{i}{L}  \\
  &&&\defeq (\lambda y. x\substuck{i}{L} + y) : \NN \to \NN  \\
  ~\\
  &A : \univ, B : A \to \univ, f : \prd{x : A} B(x)
  &&\yields f : \prd{x : A} B(x) \\
  &A : \univ, B : A \to \univ, f : \prd{x : A} B(x), \ctxlock{L}, i : \Tiny
  &&\yields f\subkey{i}{L} : \left(\prd{x : A} B(x)\right)\subkey{i}{L} \\
  &&&\defeq f\substuck{i}{L} : \prd{x : A\subkey{i}{L}} (B(x))\subkey{i}{L} \\
  &&&\defeq f\substuck{i}{L} : \prd{x : A\substuck{i}{L}} (B\substuck{i}{L})(x)
\end{alignat*}
In this last example, $B\substuck{i}{L}$ has type
$A\substuck{i}{L} \to \univ$, so applying it to $x$ is well-formed.

Applying \rulen{counit} in various locations.
\begin{alignat*}{2}
  &x : \NN,\ctxlock{K}, k : \Tiny
  &&\yields a\substuck{k}{K} : \NN \\
  &x : \NN,\ctxlock{K}, k : \Tiny, \ctxlock{L}, i : \Tiny
  &&\yields a\substuck{k}{K} \subkey{i}{L} \\
  &&&\defeq a\substuck{k\subkey{i}{L}}{K} \substuck{i}{L}  \\
  &&&\defeq a\substuck{k\substuck{i}{L}}{K} \substuck{i}{L} : \NN  \\
  ~\\
  &x : \NN, \ctxlock{K}, k : \Tiny
  &&\yields a\substuck{k}{K} : \NN \\
  &x : \NN, \ctxlock{K}, \ctxlock{L}, i : \Tiny, k : \Tiny
  &&\yields a\substuck{k}{K} \subkey{i}{L} \\
  &&&\defeq a\substuck{k\subkey{i}{L}}{K} \substuck{i}{L}  \\
  &&&\defeq a\substuck{k}{K} \substuck{i}{L} : \NN \\
  ~\\
  &x : \NN, \ctxlock{K}, k : \Tiny
  &&\yields a\substuck{k}{K} : \NN \\
  &x : \NN, \ctxlock{L}, i : \Tiny, \ctxlock{K}, k : \Tiny
  &&\yields a\substuck{k}{K} \subkey{i}{L} \\
  &&&\defeq a\substuck{i\subkey{k\subkey{i}{L}}{K}}{L} \substuck{k}{K} \\
  &&&\defeq a\substuck{i\substuck{k}{K}}{L} \substuck{k}{K} : \NN
\end{alignat*}

Applying \rulen{unit} in various locations:
\begin{alignat*}{2}
  &t : \Tiny,\ctxlock{L}, i : \Tiny
  &&\yields t\substuck{i}{L} : \Tiny \\
  &i : \Tiny
  &&\yields (t\substuck{i}{L})\sublock{L}{t} \\
  &&&\defeq t[i/t] \\
  &&&\defeq i : \Tiny \\
  ~\\
  &x : A, i : \Tiny, \ctxlock{L}, j : \Tiny
  &&\yields x\substuck{i\substuck{j}{L}}{L} : A \\
  &x : A, j : \Tiny
  &&\yields \left( x\substuck{i\substuck{j}{L}}{L} \right)\sublock{L}{i} \\
  &&&\defeq x[i\substuck{j}{L}\sublock{L}{i}/i] \\
  &&&\defeq x[i[j\sublock{L}{i}/i]/i] \\
  &&&\defeq x[i[j/i]/i] \\
  &&&\defeq x[j/i] : A
\end{alignat*}
Or even
\begin{alignat*}{2}
  &i : \Tiny, \ctxlock{L}, j : \Tiny
  &&\yields i\substuck{i\substuck{j}{L}}{L} : \Tiny \\
  &j : \Tiny
  &&\yields \left( i\substuck{i\substuck{j}{L}}{L} \right)\sublock{L}{i} \\
  &&&\defeq i\substuck{j}{L}\sublock{L}{i} \\
  &&&\defeq j\sublock{L}{i} \\
  &&&\defeq j : \Tiny
\end{alignat*}
Nothing stops us from iterating this forever:
\begin{alignat*}{2}
  &i : \Tiny, \ctxlock{L}, j : \Tiny
  &&\yields
     i\substuck{i\substuck{i\substuck{j}{L}}{L}}{L} : \Tiny
\end{alignat*}
Semantically, the context corresponds to $i : \Tiny \to \Tiny$ and $j : \Tiny$, and we are
constructing $i(i(\dots i(j)))$. The lock substitution then replaces
$i$ with the identity, and so the entire term reduces to $j$.

\iffalse
\begin{remark}
  It feels a bit as though these keys are just delayed substitutions,
  so let's try and make something interesting happen. Suppose we have
  global elements $1, 2, 3, 4 : \Tiny$, and consider the function
  \begin{align*}
    f &: (\Tiny \times \Tiny) \to \rform{L} \rform{K} (\Tiny \times \Tiny) \\
    f(x, y, \ctxlock{L}, \ctxlock{K}) &:\defeq (x\substuck{1}{L}\substuck{2}{K},y\substuck{3}{L}\substuck{4}{K})
  \end{align*}
  This can be evaluated in the following two different ways:
  \begin{align*}
    f(i, j, \rbind{i}, \rbind{j})
    & \defeq (x\substuck{1}{L}\substuck{2}{K}, y\substuck{3}{L}\substuck{4}{K})[i/x][j/y][\rbind{i}/\ctxlock{L}][\rbind{j}/\ctxlock{K}] \\
    & \defeq (i\substuck{1}{L}\substuck{2}{K}, j\substuck{3}{L}\substuck{4}{K})[\rbind{i}/\ctxlock{L}][\rbind{j}/\ctxlock{K}] \\
    & \defeq (i\substuck{1}{L}\substuck{2}{K}[\rbind{i}/\ctxlock{L}][\rbind{j}/\ctxlock{K}], j\substuck{3}{L}\substuck{4}{K}[\rbind{i}/\ctxlock{L}][\rbind{j}/\ctxlock{K}]) \\
    & \defeq (1, 4)
  \end{align*}
  and
  \begin{align*}
    f(j, i, \rbind{i}, \rbind{j})
    & \defeq (x\substuck{1}{L}\substuck{2}{K}, y\substuck{3}{L}\substuck{4}{K})[i/x][j/y][\rbind{i}/\ctxlock{L}][\rbind{j}/\ctxlock{K}] \\
    & \defeq (j\substuck{1}{L}\substuck{2}{K}, i\substuck{3}{L}\substuck{4}{K})[\rbind{i}/\ctxlock{L}][\rbind{j}/\ctxlock{K}] \\
    & \defeq (j\substuck{1}{L}\substuck{2}{K}[\rbind{i}/\ctxlock{L}][\rbind{j}/\ctxlock{K}], i\substuck{3}{L}\substuck{4}{K}[\rbind{i}/\ctxlock{L}][\rbind{j}/\ctxlock{K}]) \\
    & \defeq (2, 3)
  \end{align*}

  So the \emph{user} of a $\rformsym$ gets to choose which variable gets
  substituted for, but doesn't get to choose the value that eventually
  gets plugged in. And the values for the other $\key$s get completely
  lost!
\end{remark}
\fi

\begin{remark}
  It feels a bit as though these keys are just delayed substitutions,
  so let's try and make something interesting happen. Suppose we have
  global elements $1, 2, 3, 4 : \Tiny$, and consider a term
  \begin{align*}
    x : \Tiny, y : \Tiny, \lockn{L}, \lockn{K}
    &\yields
      (x\substuck{1}{L}\substuck{2}{K},y\substuck{3}{L}\substuck{4}{K})
      : \Tiny \times \Tiny
  \end{align*}
  Applying two different substitutions allows us to select which of
  the stuck keys to apply:
  \begin{align*}
    & (x\substuck{1}{L}\substuck{2}{K}, y\substuck{3}{L}\substuck{4}{K})[i/x][j/y][\rbind{i}/\ctxlock{L}][\rbind{j}/\ctxlock{K}] \\
    & \defeq (i\substuck{1}{L}\substuck{2}{K}, j\substuck{3}{L}\substuck{4}{K})[\rbind{i}/\ctxlock{L}][\rbind{j}/\ctxlock{K}] \\
    & \defeq (i\substuck{1}{L}\substuck{2}{K}[\rbind{i}/\ctxlock{L}][\rbind{j}/\ctxlock{K}], j\substuck{3}{L}\substuck{4}{K}[\rbind{i}/\ctxlock{L}][\rbind{j}/\ctxlock{K}]) \\
    & \defeq (1, 4)
  \end{align*}
  and
  \begin{align*}
    & (x\substuck{1}{L}\substuck{2}{K}, y\substuck{3}{L}\substuck{4}{K})[i/x][j/y][\rbind{i}/\ctxlock{L}][\rbind{j}/\ctxlock{K}] \\
    & \defeq (j\substuck{1}{L}\substuck{2}{K}, i\substuck{3}{L}\substuck{4}{K})[\rbind{i}/\ctxlock{L}][\rbind{j}/\ctxlock{K}] \\
    & \defeq (j\substuck{1}{L}\substuck{2}{K}[\rbind{i}/\ctxlock{L}][\rbind{j}/\ctxlock{K}], i\substuck{3}{L}\substuck{4}{K}[\rbind{i}/\ctxlock{L}][\rbind{j}/\ctxlock{K}]) \\
    & \defeq (2, 3)
  \end{align*}
  Once we have the type former, we will be able to cause these
  different substitutions to occur. So the \emph{user} of a term
  containing stuck keys gets to choose which stored term is eventually
  used, but doesn't get to choose the term that gets plugged in. And
  the stored terms for the other $\key$s are completely lost!
\end{remark}

\section{Type}

The type former is now made right-adjoint to $\ctxlock{L}$ in the
`obvious' way, following the pattern of \cite{fitchtt}.

\mvrnote{This specific choice of syntax may be where I lose the crowd,
  but I will try to justify it in a minute.}

% \begin{mathpar}
%   \inferrule*[left=$\surd$-form]
%   {\Gamma, \ctxlock{L} \yields A : \univ}
%   {\Gamma \yields \rform{L} A : \univ} \and
%   \inferrule*[left=$\surd$-intro]
%   {\Gamma, \ctxlock{L} \yields a : A}
%   {\Gamma \yields \rintro{L} a : \rform{L} A} \and
%   \inferrule*[left=$\surd$-elim]
%   {\Gamma, i : \Tiny \yields r : \rform{L} A}
%   {\Gamma \yields \relim{i.r} : A\sublock{L}{i}} \\
%   \relim{i.\rintro{L} a} \defeq a\sublock{L}{i} \and
%   r \defeq \rintro{L}{\relim{i. r\subkey{i}{L}}}
% \end{mathpar}
\begin{mathpar}
  \inferrule*[left=$\surd$-form]
  {\Gamma, \ctxlock{L} \yields A : \univ}
  {\Gamma \yields \rform{L} A : \univ} \and
  \inferrule*[left=$\surd$-intro]
  {\Gamma, \ctxlock{L} \yields a : A}
  {\Gamma \yields \rintro{L} a : \rform{L} A} \and
  \inferrule*[left=$\surd$-elim]
  {\Gamma, i : \Tiny \yields r : \rform{L} A}
  {\Gamma \yields r(\rbind{i}) : A\sublock{L}{i}} \\
  (\rintro{L}{a})(\rbind{i}) \defeq a\sublock{L}{i} \and
  r \defeq \rintro{L}{(r\subkey{i}{L}(\rbind{i}))}
\end{mathpar}

\begin{itemize}
\item \rulen{$\surd$-form}/\rulen{$\surd$-intro}: For any
  `$\ctxlock{L}$-locked' term $a : A$, we can amazingly bind the lock
  $\lockn{L}$ and form a term $\rintro{L} a : \rform{L} A$. The syntax
  is intended to be similar to that of an ordinary $\lambda$-binding.

  Reading upwards, going under $\rform{L} - $ means that all extant
  variables get locked by $\ctxlock{L}$, so every future use of those
  variables in $a$ must have an attached $-\subkey{t}{L}$.

  If $A$ is a closed type, we will just write $\rformu A$ rather than
  binding a lock name that doesn't get used.
\item \rulen{$\surd$-elim}: If given an assumption $i : \Tiny$ we can
  produce a term $r : \rform{L} A$, then we can amazingly apply $r$ to
  the fresh $i$ to form $r(\rbind{i}) : A$. We are free to completely
  ignore the new assumption $i$, just as a constant function ignores
  its argument.

  The syntax is a bit insane: to keep the analogy with ordinary
  function application, the variable $i$ is bound in the parentheses
  on the right, but then is \emph{in scope in the body of the function}.
\item \rulen{$\surd$-beta}: Amazingly binding a lock $\rintro{L} a$
  and then amazingly applying it to $\rbind{i}$ reduces to
  $a\sublock{L}{i}$, in complete analogy with
  $(\lambda x. b)(a) \defeq b[a/x]$.
\item \rulen{$\surd$-eta}:
\end{itemize}

\subsection{Basic Properties}

First, two basic maps that are easily definable from the rules.

\begin{definition}
  If $A$ is a (for now) closed type, define
  $\varepsilon_A : \rformu{A} \to A$ by
  \begin{align*}
    \varepsilon_A &: \rformu{A} \to A \\
    \varepsilon_A(r) &:\defeq r(\rbind{i})
  \end{align*}
  To get a term of $A$, we need a term of $\rformu{A}$ that we can
  amazingly evaluate on an additional assumption $i : \Tiny$. But we
  have the variable $r : \rformu{A}$ already, so we have no need to
  use the additional assumption.
\end{definition}

\begin{definition}
  For $f : A \to B$ a closed function, define $\rformu f$ by
  \begin{align*}
    \rformu f &: \rform{L} A \to \rform{K} B \\
    (\rformu f)(r) &:\defeq \rintro{K}{f(r\substuck{i}{K}(\rbind{i}))}
    % \rformu f(r) &:\defeq \rintro{L}{f(\relim{i.r\substuck{i}{L}})}
  \end{align*}
\end{definition}

Compare this with the definition of ordinary function composition, as
the shape of the definition is very similar:
\begin{align*}
  f \circ - &: (C \to A) \to (C \to B) \\
  (f \circ -)(r) &:\defeq \lambda c. f(r(c))
\end{align*}

In words, we start with $r : \rform{L} A$. To produce a term of
$\rform{K} B$ we have to produce a `$\lockn{K}$-locked' term of
$B$. There is a function $f : A \to B$ available, so we just have to
get a $\lockn{K}$-locked term of $A$. We cannot amazingly evaluate
$r : \rform{L} A$ on its own because it became trapped behind
$\ctxlock{K}$. But we \emph{can} amazingly evaluate $r\substuck{i}{K}$
on an additional assumption $i : \Tiny$. This gets us a
$\lockn{K}$-locked term of $A$ which we can apply $f$ to, giving the
$\lockn{K}$-locked term of $B$ that we wanted. This time, the access
to the additional term $i : \Tiny$ was crucial: it is exactly what we
needed to access $r$ via $r\substuck{i}{K} : \rform{L}{A}$.

If $f$ is not closed then this is not well-typed, because $f$ as a
variable also became locked behind $\ctxlock{L}$. But if \emph{all}
the inputs to the above construction are provided under $\rformu$,
then we can have access to a function $A \to B$ where we need it. In
full generality:
\begin{definition}
  For $A,B : \rformu \univ$ and
  $f : \rform{L}\left((\relim{i.A\substuck{i}{L}}) \to
    (\relim{i.B\substuck{i}{L}})\right)$, define $\rformu f$ by
  \begin{align*}
    \rformu f &: \rform{L}\left(\relim{i.A\substuck{i}{L}}\right) \to \rform{L}\left( \relim{i.B\substuck{i}{L}}\right) \\
    \rformu f(r) &:\defeq \rintro{L}{(\relim{j. f\substuck{j}{L}})(\relim{i.r\substuck{i}{L}})}
  \end{align*}
\end{definition}

This simple example is already very noisy, so to cut down on the
symbols let us fix a couple of pieces of notation.

Like ordinary \rulen{$\to$-intro}, and as with any negative type
former, the \rulen{$\surd$-intro} rule is right-invertible and so we
may define terms of it via copattern matching~\cite{???}. For example,
we will write
\begin{align*}
  r(\ctxlock{L}, \ctxlock{K}) :\defeq \judge
  \quad \text{to mean} \quad
  r :\defeq \rintro{L}{\rintro{K}{\judge}}
\end{align*}
This combines nicely with ordinary copattern-style definitions of
functions. We write
\begin{align*}
  f(x,y,\ctxlock{L},z) :\defeq \judge
  \quad \text{to mean} \quad
  f :\defeq \lambda x. \lambda y. \rintro{L}{\lambda z. \judge}
\end{align*}
This syntax makes it easy to see at a glance which locks each variable
is locked by in the term $\judge$: the $x$ and $y$ here are to the
left of $\ctxlock{L}$ in the list of arguments and so are locked by
$\ctxlock{L}$, whereas $z$ is not locked by anything.

Eliminating a term of $\rformu{A}$ described this style is a little
peculiar.  To `apply' a lock we bind a new variable $i$ as in
$\surd$-elimination, but this variable is now in scope \emph{to the
  left} of the that lock in the argument list\footnote{Of course if we
  took Lawvere seriously~\cite{lawvere:adjointness-foundations} and
  wrote function application as $xf$, then we would not have this
  issue!}. We write
\begin{align*}
  f(a(i), b(i), \rbind{i}, c)
  \quad \text{to mean} \quad
  \left(\relim{i. f(a(i), b(i))}\right)(c)
\end{align*}
These compute in the `obvious' way, with a $\beta$-reduction for each
entry in the list of arguments. If $f$ is defined via the pattern
match above, we find
\begin{align*}
  f(a(i), b(i), \rbind{i}, c)
  &\defeq \left(\relim{i. f(a(i), b(i))}\right)(c) \\
  &\defeq \left(\relim{i. \left( \lambda x. \lambda y. \rintro{L}{\lambda z. \judge} \right)(a(i), b(i))}\right)(c) \\
  &\defeq \left(\relim{i. \rintro{L}{\lambda z. \judge}[a(i)/x][b(i)/y]}\right)(c) \\
  &\defeq \left(\lambda z. \judge[a(i)/x][b(i)/y]\sublock{L}{i}\right)(c) \\
  &\defeq \judge[a(i)/x][b(i)/y]\sublock{L}{i}[c/z]
\end{align*}
We have arranged the syntax of our admissible rules precisely so that
the function definition and use site click together: comparing
$f(a(i), b(i), \rbind{i}, c)$ and $f(x,y,\ctxlock{L},z)$, the first
arguments become substitutions $[a(i)/x][b(i)/y]$ and the $\rbind{i}$
`argument' becomes a `substitution' $\sublock{L}{i}$.

\mvrnote{Mention here that $f$ can use $i$ in its definition}

Any ordinary function is tautologically equal to the `definition'
\begin{align*}
  f(x) :\defeq f(x)
\end{align*}
by $\eta$-expansion. For $\surd$, this $\eta$-expansion introduces an
instance of key substitution. That is, for any $f : \rform{L}{A}$,
\begin{align*}
  r(\ctxlock{L}) :\defeq (r\substuck{i}{L})(\rbind{i})
\end{align*}


For the second piece of syntactic sugar, we will often need to extract terms of $A$ from assumptions
$r : \rformu{A}$, using the counit $\varepsilon_A$ defined above. When
such assumptions are behind many context locks, the
\rulen{$\surd$-elim} rule provides a term $i : \Tiny$ that can be used
to unlock all these context locks at once, giving us access to $A$
regardless of where $r$ lies in the context.
\begin{definition}
  If $x : \rform{L} A$ is behind several locks
  $\ctxlocke{\lockn{K}_1} \dots \ctxlocke{\lockn{K}_n}$, then let
  \begin{align*}
    \rget{x} :\defeq (x \substucke{i}{\lockn{K}_1}
    \dots \substucke{i}{\lockn{K}_n})(\rbind{i}) : A \subkeye{i}{\lockn{K}_1}
    \dots \subkeye{i}{\lockn{K}_n}\sublock{L}{i}
  \end{align*}
  in particular, if $x : \rform{L} A$ is behind no locks in the
  context then $\rget{x} :\defeq \varepsilon_A(x)$.
\end{definition}
(This notation cannot be internalised as a function, it is just an
admissible piece of syntax.)  This allows a different perspective on
$\eta$-expansion for $\rformsym$: for any term $r : \rformu A$, there
is a judgemental equality $r \defeq \rintro{L}{\rget{r}}$.

Using these shorthand, the definition of functoriality is much clearer:
For $A,B : \rformu \univ$ and
$f : \rform{L}\left(\rget{A} \to \rget{B}\right)$ we have
\begin{alignat*}{2}
  &\rformu f &&: \rform{L}\rget{A} \to \rform{L}\rget{B} \\
  &\rformu f(r, \ctxlock{L}) &&:\defeq \rget{f}(\rget{r})
\end{alignat*}
or
\begin{align*}
  \rformu f(r, \ctxlock{L}) &:\defeq (f\substuck{i}{L})(\rbind{i}, (r\substuck{j}{L})(\rbind{j}))
\end{align*}

Now let's look at how $\rformu$ relates to $(\Tiny \to -)$
\begin{definition}
  If $A : \univ$ is a (for now) closed type, there are maps
  \begin{align*}
    \eta_A &: A \to \rformu(\Tiny \to A) \\
    \varepsilon_A &: (\Tiny \to \rformu A) \to A
  \end{align*}
  given by
  % \begin{align*}
  %   \eta_A(a) &:\defeq \rintro{L}{\lambda t. \varkey{L}{t} a} \\
  %   \varepsilon_A(f) &:\defeq \relim{i.f(i)}
  % \end{align*}
  \begin{align*}
    \eta_A(a, \ctxlock{L}, t) &:\defeq a \substuck{t}{L} \\
    \varepsilon_A(f) &:\defeq f(i, \rbind{i})
  \end{align*}
  Allowing dependency, for \emph{any} $A : \univ$, there is a map
  \begin{align*}
    \eta_A &: A \to \rform{L}(\prd{t : \Tiny} A \substuck{t}{L})
  \end{align*}
  and for \emph{any} $B : \Tiny \to \rformu \univ$ a map
  \begin{align*}
    \varepsilon_B &: \left(\prd{t:\Tiny} \rform{K} \relim{j.(B
                    \substuck{j}{K})(t\substuck{j}{K})}\right) \to \relim{j.B(j)}
  \end{align*}
  or
  \begin{align*}
    \varepsilon_B &: \left(\prd{t:\Tiny} \rform{K} (B \substuck{j}{K})(t\substuck{j}{K}, \rbind{j})\right) \to B(j, \rbind{j})
  \end{align*}
  with the same definitions as in the closed case.
\end{definition}

Let us typecheck $\varepsilon_B(f) :\defeq f(i, \rbind{i})$ against
that latter expression. The term $f(i)$ has type
$\rform{K} \relim{j.(B \substuck{j}{K})(i \substuck{j}{K})}$, and so
$f(i, \rbind{i})$ has type
\begin{align*}
  &\left(\relim{j.(B \substuck{j}{K})(i
    \substuck{j}{K})}\right)\sublock{K}{i} \\
  &\defeq \relim{j.(B \substuck{j}{K}\sublock{K}{i})(i \substuck{j}{K}\sublock{K}{i})} \\
  &\defeq \relim{j.(B[j/i])(i[j/i])} \\
  &\defeq \relim{j.B(j)}
\end{align*}
which is what we wanted.
or
\begin{align*}
  &\left((B \substuck{j}{K})(i \substuck{j}{K}, \rbind{j})\right)\sublock{K}{i} \\
  &(B \substuck{j}{K}\sublock{K}{i})(i \substuck{j}{K}\sublock{K}{i}, \rbind{j}) \\
  &(B [j/i])(i [j/i], \rbind{j}) \\
  &B(j, \rbind{j})
\end{align*}

Besides $\varepsilon_A$ not being definable for arbitrary $A$, we have
also seen that $\rformu -$ is not internally functorial. So to what
extent do we actually get the adjointness $-^{\Tiny} \dashv \rformu -$?
\begin{proposition}
  If $A$ and $B$ are closed types then there is an equivalence
  \begin{align*}
    \Phi : \rformu ((\Tiny \to A) \to B) \to (A \to \rformu B)
  \end{align*}
  given by
  % \begin{alignat*}{2}
  %   g &\mapsto \lambda a. \rintro{L}{\rget{g}(\lambda j.\varkey{L}{j} a)} &&: \rformu((\Tiny \to A) \to B) \to (A \to \rformu B) \\
  %   f &\mapsto \rintro{K}{\lambda h. \relim{i.(\varkey{K}{i} f)(h(i))}} &&: (A \to \rformu B) \to \rformu ((\Tiny \to A) \to B)
  % \end{alignat*}

  % \begin{alignat*}{2}
  %   \hat g(a, \ctxlock{L}) &:\defeq \rget{g}(\lambda j.\varkey{L}{j} a) \\
  %   \hat f(\ctxlock{K}, h) &:\defeq \relim{i.(\varkey{K}{i} f)(h(i))}
  % \end{alignat*}

  \begin{alignat*}{2}
    (\Phi g)(a, \ctxlock{L})
    &:\defeq (g\substuck{i}{L})(\rbind{i}, \lambda j. a \substuck{j}{L}) \\
    (\Phi^{-1} f)(\ctxlock{K}, h)
    &:\defeq (f\substuck{k}{K})(h(k), \rbind{k})
  \end{alignat*}
  \mvrnote{The $i.$ binding extends all the way into the function being evaluated!}
\end{proposition}
\begin{proof}
  Crunching through the composite:
  % \begin{align*}
  %   (\Phi^{-1} (\Phi g))(\ctxlock{K}, h)
  %   &\defeq ((\Phi g) \subkey{k}{K})(h(k), \rbindsym k.) \\
  %   &\defeq (\Phi (g\substuck{k}{K}))(h(k), \rbindsym k.) \\
  %   &\defeq \left( (g\substuck{k}{K}\subkey{i}{L})(\rbind{i}, \lambda j. a \substuck{j}{L}) \right)[h(k)/a]\sublock{L}{k} \\
  %   &\defeq \left( (g\substuck{k\substuck{i}{L}}{K}\substuck{i}{L})(\rbind{i}, \lambda j. a \substuck{j}{L}) \right)[h(k)/a]\sublock{L}{k} \\
  %   &\defeq \left( (g\substuck{k\substuck{i}{L}}{K}\substuck{i}{L})(\rbind{i}, \lambda j. h(k) \substuck{j}{L}) \right)\sublock{L}{k} \\
  %   &\defeq
  %     (g\substuck{k\substuck{i}{L}}{K}\substuck{i}{L}\sublock{L}{k}))(\rbindsym
  %     i., \lambda j. h(k) \substuck{j}{L}\sublock{L}{k})  \\
  %   &\defeq (g\substuck{k\substuck{i}{L}\sublock{L}{k}}{K})(\rbindsym
  %     i., \lambda j. h(k) [j/k]) \\
  %   &\defeq (g\substuck{k[i/k]}{K})(\rbind{i}, \lambda j. h(k)
  %     [j/k]) \\
  %   &\defeq (g\substuck{i}{L})(\rbind{i}, \lambda j. h(j)) \\
  %   &\defeq (g\substuck{i}{L})(\rbind{i}, h)
  % \end{align*}
  \begin{align*}
    &(\Phi^{-1} (\Phi g))(\ctxlock{K}, h) \\
    &\defeq ((\Phi g) \subkey{k}{K})(h(k), \rbind{k})
    && \text{(Definition of $\Phi^{-1}$)} \\
    &\defeq (\Phi (g\substuck{k}{K}))(h(k), \rbind{k})
    && \text{($\Phi$ is closed)} \\
    &\defeq \left( (g\substuck{k}{K}\subkey{i}{L})(\rbind{i}, \lambda j. a \substuck{j}{L}) \right)[h(k)/a]\sublock{L}{k}
    && \text{(Definition of $\Phi$)} \\
    &\defeq \left( (g\substuck{k}{K}\subkey{i}{L})(\rbind{i}, \lambda j. (h(k)) \substuck{j}{L}) \right)\sublock{L}{k}
    && \text{(Performing $[h(k)/a]$)} \\
    &\defeq (g\substuck{k}{K}\subkey{i}{L}\sublock{L}{k})(\rbind{i}, \lambda j. (h(k)) \substuck{j}{L}\sublock{L}{k})
    && \text{(Commuting $\sublock{L}{k}$ with application)} \\
    &\defeq (g\substuck{k}{K}[i/k])(\rbind{i}, \lambda j. (h(k)) [j/k])
    && \text{(Computing $\subkey{-}{L}\sublock{L}{k}$)} \\
    &\defeq (g\substuck{i}{K})(\rbind{i}, \lambda j. h(j))
    && \text{(Substitution)} \\
    &\defeq (g\substuck{i}{K})(\rbind{i}, h)
    && \text{($\eta$ for functions)}
  \end{align*}
  and this is precisely the $\eta$-expansion of $g$.

  The other way:
  \begin{align*}
    &(\Phi (\Phi^{-1} f))(a, \ctxlock{L}) \\
    &\defeq ((\Phi^{-1} f)\substuck{i}{L})(\rbind{i}, \lambda j. a \substuck{j}{L})
    && \text{(Definition of $\Phi$)} \\
    &\defeq (\Phi^{-1} f\substuck{i}{L})(\rbind{i}, \lambda j. a \substuck{j}{L})
    && \text{($\Phi^{-1}$ is closed)} \\
    &\defeq (f\substuck{i}{L}\subkey{k}{K})(h(k), \rbind{k})\sublock{K}{i}[\lambda j. a \substuck{j}{L}/h]
    && \text{(Definition of $\Phi^{-1}$)} \\
    &\defeq (f\substuck{i}{L}\subkey{k}{K}\sublock{K}{i})(h(k), \rbind{k})[\lambda j. a \substuck{j}{L}/h]
    && \text{(Commuting $\sublock{K}{i}$)} \\
    &\defeq (f\substuck{i}{L}[k/i])(h(k), \rbind{k})[\lambda j. a \substuck{j}{L}/h]
    && \text{(Computing $\subkey{k}{K}\sublock{K}{i}$)} \\
    &\defeq (f\substuck{k}{L})(h(k), \rbind{k})[\lambda j. a \substuck{j}{L}/h]
    && \text{(Performing $[k/i]$)} \\
    &\defeq (f\substuck{k}{L})((\lambda j. a \substuck{j}{L})(k), \rbind{k})
    && \text{(Performing $[\lambda j. a \substuck{j}{L}/h]$)} \\
    &\defeq (f\substuck{k}{L})(a \substuck{k}{L}, \rbind{k})
    && \text{($\beta$ for functions)}
  \end{align*}
  which, again, is the $\eta$-expansion of $f$.

  \iffalse
  Crunching through both directions:
  \begin{align*}
    &\rintro{K}{\lambda h. \relim{i.(\admkey{K}{i} \left(\lambda a. \rintro{L}{\rget{g}(\lambda j.\varkey{L}{j} a)}\right))(h(i))}} \\
    &\defeq \rintro{K}{\lambda h. \relim{i.(\admkey{K}{i} \left(\lambda a. \rintro{L}{(\relim{l.\varkey{L}{l} g})(\lambda j.\varkey{L}{j} a)}\right))(h(i))}} && \text{(Expanding $\rget g$)} \\
    &\defeq \rintro{K}{\lambda h. \relim{i.\left(\lambda a. \rintro{L}{(\relim{l.\varkey{L}{l} \varkey{K}{i} g})(\lambda j.\varkey{L}{j} a)}\right)(h(i))}} && \text{(Computing $\admkey{K}{i}$)} \\
    &\defeq \rintro{K}{\lambda h. \relim{i.\rintro{L}{(\relim{l.\varkey{L}{l} \varkey{K}{i} g})(\lambda j.\admkey{L}{j} h(i))}}} && \text{($\beta$ for $\to$ on $a$)} \\
    &\defeq \rintro{K}{\lambda h. \relim{i.\rintro{L}{(\relim{l.\varkey{L}{l} \varkey{K}{i} g})(\lambda j.(\varkey{L}{j} h)(\varkey{L}{j} i))}}} && \text{(Computing $\admkey{L}{j}$)} \\
    &\defeq \rintro{K}{\lambda h. (\relim{l.\varkey{L}{l} \varkey{K}{i} g})(\lambda j.(\varkey{L}{j} h)(\varkey{L}{j} i))[\sublock{L}{i}]} && \text{($\beta$ for $\rformu$)} \\
    &\defeq \rintro{K}{\lambda h. (\relim{l.\varkey{K}{l} g})(\lambda j.h( j))} && \text{(Computing $\sublock{L}{i}$)} \\
    &\defeq \rintro{K}{\lambda h. (\relim{l.\varkey{K}{l} g})(h)} && \text{($\beta$ for $\to$ on $j$)} \\
    &\defeq \rintro{K}{\relim{l.\varkey{K}{l} g}} && \text{($\beta$ for $\to$ on $h$)} \\
    &\defeq g && \text{($\eta$ for $\rformu$)} \\
  \end{align*}
  and
  \begin{align*}
    &\lambda a. \rintro{L}{(\relim{l.\admkey{L}{l} \left(\rintro{K}{\lambda h. \relim{i.(\varkey{K}{i} f)(h(i))}}\right)})(\lambda j.\varkey{L}{j} a)} \\
    &\defeq \lambda a. \rintro{L}{(\relim{l. \rintro{K}{\lambda h. \relim{i.(\varkey{K}{i} \varkey{L}{l} f)(h(i))}}})(\lambda j.\varkey{L}{j} a)} && \text{(Computing $\admkey{L}{l}$)} \\
    &\defeq \lambda a. \rintro{L}{(\lambda h. \relim{i.(\varkey{K}{i} \varkey{L}{l} f)(h(i))}[\sublock{K}{l}])(\lambda j.\varkey{L}{j} a)} && \text{($\beta$ for $\rformu$)} \\
    &\defeq \lambda a. \rintro{L}{(\lambda h. \relim{i.( \varkey{L}{i} f)(h(i))})(\lambda j.\varkey{L}{j} a)} && \text{(Computing $\sublock{K}{l}$)} \\
    &\defeq \lambda a. \rintro{L}{\relim{i.(\varkey{L}{i} f)((\lambda j.\varkey{L}{j} a)(i))}} && \text{($\beta$ for $\to$ on $h$)} \\
    &\defeq \lambda a. \rintro{L}{\relim{i.(\varkey{L}{i} f)(\varkey{L}{i} a))}} && \text{($\beta$ for $\to$ on $j$)} \\
    &\defeq \lambda a. \rintro{L}{\relim{i.\admkey{L}{i}(f(a))}} && \text{(`Uncomputing' $\admkey{L}{i}$)} \\
    &\defeq \lambda a. f(a) && \text{($\eta$ for $\rformu$)} \\
    &\defeq f && \text{($\eta$ for $\to$)}
  \end{align*}
  \fi
\end{proof}

\begin{remark}
  Internal equivalences of this kind for an arbitrary adjoint modality
  have been defined in MTT, where the modality is instead a positive
  type former, see~\cite[Proposition 3.4]{transpension}
  and~\cite[Section 10.4]{mtt}. The fact that this internal
  formulation circumvents the `no-go' theorem of \cite{lops} was also
  noted in \cite[Section 10.1]{transpension}.
\end{remark}

Happily, we can allow $A$ and $B$ to be dependent types:
\begin{proposition}\label{prop:adj}
  For any $A : \univ$ and $B : \rformu \univ$, there is an equivalence
  \begin{align*}
    \rform{L} ((\prd{t:\Tiny} A\substuck{t}{L}) \to \rget{B}) \equiv (A \to \rform{L} \rget{B})
  \end{align*}
  with maps defined the same way as above.
\end{proposition}
And in fact, we can also let $B$ depend on $A$:
\begin{proposition}\label{prop:dep-adj}
  For any $A : \univ$ and $B : A \to \rformu \univ$, there is an
  equivalence
  % \begin{align*}
  %   \left(\prd{a:A} \rform{L} \rget{B(a)}\right) \equiv \rform{L} \left(\prd{f:\prd{t:\Tiny} A\substuck{t}{L}} \relim{i.(B\substuck{i}{L})(f(i))}\right)
  % \end{align*}
  \begin{align*}
    \rform{L} \left(\prd{f:\prd{t:\Tiny} A\substuck{t}{L}} B\substuck{i}{L}(f(i), \rbind{i})\right) \equiv \prd{a:A} \rform{L} \rget{B(a)}
  \end{align*}
  with maps defined the same way as above. \mvrnote{The notation here
    is so heavy that it's hard to see the original adjunction
    underneath it...}
\end{proposition}

% But we are actually running into the weak variable rule issue
% already. We want the type of the second one to be
% $\rformu((\Tiny \to A) \to B) \to \rform{K}(A \to \rform{L} B)$, but
% because of the two contexts locks $\ctxlock{\lockn{K}}$ and
% $\ctxlock{\lockn{L}}$, we actually can't access $g$ where we need
% to.

% \begin{lemma}
%If $A$ is closed, the triangle identities hold:
%\begin{align*}
%(\varepsilon_{\Tiny \to A}) \circ (\Tiny \to {\eta_A}) &\defeq \id_{\Tiny \to A} \\
%(\rformu \varepsilon_A) \circ (\eta_{\rformu A}) &\defeq \id_{\rformu A}
%\end{align*}
%\end{lemma}
%We can use functoriality on $\varepsilon_A$ here, because it is a closed function as long as $A$ is a closed type. I think the above could probably be made to work with a non-closed $A : \rformu \univ$, but it would take some fiddling to line things up.
%\begin{proof}
%Let us expand each function on its own, $\alpha$-renaming things so they don't clash.
%\begin{align*}
%(\Tiny \to {\eta_A})(g) &\defeq \lambda s. \rintro{L}{\lambda t. \varkey{L}{t} (g(s))} \\
%(\varepsilon_{\Tiny \to A})(f) &\defeq \relim{i.f(i)}\\
%(\eta_{\rformu A})(x) &\defeq \rintro{L}{\lambda t. \varkey{L}{t} x}\\
%(\rformu \varepsilon_A)(w) &\defeq \rintro{K}{\relim{j.\relim{i.\varkey{K}{i} w}(j)}}
%\end{align*}
%And now composing them and reducing:
%\begin{align*}
%&(\varepsilon_{\Tiny \to A}) \circ (\Tiny \to {\eta_A})(g) \\
%&\defeq \relim{i.\left[\lambda s. \rintro{L}{\lambda t. \varkey{L}{t} (g(s))} \right](i)} \\
%&\defeq \relim{i.\rintro{L}{\lambda t. \varkey{L}{t} (g(i))}} \\
%&\defeq \left(\lambda t. \varkey{L}{t} (g(i))\right)[\sublock{L}{i}] \\
%&\defeq \lambda t. (g(i))[t/i] \\
%&\defeq \lambda t. g(t) \\
%&\defeq g
%\end{align*}
%and
%\begin{align*}
%&(\rformu \varepsilon_A) \circ (\eta_{\rformu A})(x) \\
%&\defeq \rintro{K}{\relim{j.\relim{i.\admkey{K}{i} \left[\rintro{L}{\lambda t. \varkey{L}{t} x}\right]}(j)}} \\
%&\defeq \rintro{K}{\relim{j.\relim{i.\rintro{L}{\lambda t. \varkey{L}{t} \varkey{K}{i} x}}(j)}} \\
%&\defeq \rintro{K}{\relim{j.(\lambda t. \varkey{L}{t} \varkey{K}{i} x)[\sublock{L}{i}](j)}} \\
%&\defeq \rintro{K}{\relim{j.(\lambda t. \varkey{K}{t} x)(j)}} \\
%&\defeq \rintro{K}{\relim{j. \varkey{K}{j} x}} \\
%&\defeq x
%\end{align*}
% \end{proof}
\iffalse
\subsection{Comonad}
$\rformu$ is supposed to be a comonad, because it is right adjoint to
the monad $(\Tiny \to -)$. We could get the comonad structure from the
above adjunction, but the maps are easy to define directly:

\begin{proposition}
  $\rform{}$ is a comonad, where for any $A : \rformu \univ$,
  \begin{alignat*}{2}
    \varepsilon_A &:\defeq (\lambda r. \relim{\_.r}) &&: \rform{L} \rget{A} \to \rget{A} \\
    \delta_A &:\defeq (\lambda s. \rintro{J}{\rintro{K}{\relim{l.\varkey{K}{l}\varkey{J}{l}s}}}) &&: \rform{L} \rget{A} \to \rform{J} \rform{K} \rget{A}
  \end{alignat*}

  \begin{align*}
    \varepsilon_A(r)
    &:\defeq \relim{\_.r} \\
    \delta_A(s, \ctxlock{J}, \ctxlock{K})
    &:\defeq \relim{i.s\substuck{i}{J}\substuck{i}{K}}
  \end{align*}
  Or even
  \begin{align*}
    \varepsilon_A(r) &:\defeq \rget{r} \\
    \delta_A(s, \ctxlock{J}, \ctxlock{K}) &:\defeq \rget{s}
  \end{align*}
  Or even
  \begin{align*}
    \varepsilon_A(r) &:\defeq r(\rbind{\_}) \\
    \delta_A(s, \ctxlock{J}, \ctxlock{K}) &:\defeq (s\substuck{i}{J}\substuck{i}{K})(\rbind{i})
  \end{align*}
\end{proposition}
\begin{proof}
  Checking these by hand is a pain. A hypothetical proof assistant
  would be convinced by $\refl{}$, because all the identities involved
  are definitional.
  \begin{align*}
    \rformu \varepsilon_A \circ \delta_A
    &: \rform{L} \rget{A} \to \rform{L} \rget{A} \\
    (\rformu \varepsilon_A \circ \delta_A)(r, \rbind{i})
    &:\defeq (\rformu \varepsilon_A \circ \delta_A)(r, \rbind{i}) \\
    &\defeq (\rformu \varepsilon_A)(\delta_A(r, \rbind{i})) \\
    &\defeq (\rformu \varepsilon_A)(\rintro{K}{\delta_A(r\substuck{k}{K}, \rbind{i}, \rbind{k})}) \\
    &\defeq (\rformu \varepsilon_A)(\rintro{K}{(s\substuck{i}{J}\substuck{i}{K})(\rbind{i})}) \\
  \end{align*}

  \begin{align*}
    \rformu \varepsilon_A \circ \delta_A
    &:\defeq \rformu (\lambda r. \relim{\_.r}) \circ (\lambda s. \rintro{J}{\rintro{K}{\relim{l.\varkey{K}{l}\varkey{J}{l}s}}}) \\
    &:\defeq \lambda r. \rintro{L}{(\lambda r. \relim{\_.r})(\relim{i.\varkey{L}{i}r})} \circ (\lambda s. \rintro{J}{\rintro{K}{\relim{l.\varkey{K}{l}\varkey{J}{l}s}}}) \\
    &\defeq \lambda r. \rintro{L}{\relim{\_.\relim{i.\varkey{L}{i}r}}} \circ (\lambda s. \rintro{J}{\rintro{K}{\relim{l.\varkey{K}{l}\varkey{J}{l}s}}}) \\
    &\defeq \lambda r. \rintro{L}{\relim{\_.\relim{i.\admkey{L}{i}\rintro{J}{\rintro{K}{\relim{l.\varkey{K}{l}\varkey{J}{l}r}}}}}} \\
    &\defeq \lambda r. \rintro{L}{\relim{\_.\relim{i.\rintro{J}{\rintro{K}{\relim{l.\varkey{K}{l}\varkey{J}{l}\varkey{L}{i}r}}}}}} \\
    &\defeq \lambda r. \rintro{L}{\relim{\_.\rintro{K}{\relim{l.\varkey{K}{l}\varkey{L}{l}r}}}} \\
    &\defeq \lambda r. \rintro{L}{\relim{l.\varkey{L}{l}r}} \\
    &\defeq \lambda r. r \\
    ~\\
    \varepsilon_{\rform{J} A} \circ \delta_A &:\defeq (\lambda r. \relim{\_.r}) \circ (\lambda s. \rintro{J}{\rintro{K}{\relim{l.\varkey{K}{l}\varkey{J}{l}s}}}) \\
    &\defeq \lambda r. \relim{\_.\rintro{J}{\rintro{K}{\relim{l.\varkey{K}{l}\varkey{J}{l}r}}}} \\
    &\defeq \lambda r. \rintro{K}{\relim{l.\varkey{K}{l}r}} \\
    &\defeq \lambda r. r \\
  \end{align*}
  \begin{align*}
    \rformu \delta_A \circ \delta_A
    &:\defeq \rformu (\lambda s'. \rintro{J'}{\rintro{K'}{\relim{l'.\varkey{K'}{l'}\varkey{J'}{l'}s'}}})  \circ (\lambda s. \rintro{J}{\rintro{K}{\relim{l.\varkey{K}{l}\varkey{J}{l}s}}}) \\
    &:\defeq (\lambda r. \rintro{M}{\rintro{J'}{\rintro{K'}{\relim{l'.\admkey{K'}{l'}\admkey{J'}{l'}\relim{i.\varkey{M}{i}{r}}}}}})  \circ (\lambda s. \rintro{J}{\rintro{K}{\relim{l.\varkey{K}{l}\varkey{J}{l}s}}}) \\
    &\defeq (\lambda r. \rintro{M}{\rintro{J'}{\rintro{K'}{\relim{l'.\relim{i.\varkey{K'}{l'}\varkey{J'}{l'}\varkey{M}{i}{r}}}}}})  \circ (\lambda s. \rintro{J}{\rintro{K}{\relim{l.\varkey{K}{l}\varkey{J}{l}s}}}) \\
    &\defeq \lambda r. \rintro{M}{\rintro{J'}{\rintro{K'}{\relim{l'.\relim{i.\admkey{K'}{l'}\admkey{J'}{l'}\admkey{M}{i}{\rintro{J}{\rintro{K}{\relim{l.\varkey{K}{l}\varkey{J}{l}r}}}}}}}}} \\
    &\defeq \lambda r. \rintro{M}{\rintro{J'}{\rintro{K'}{\relim{l'.\relim{i.{\rintro{J}{\rintro{K}{\relim{l.\varkey{K}{l}\varkey{J}{l}\varkey{K'}{l'}\varkey{J'}{l'}\varkey{M}{i}r}}}}}}}}} \\
    &\defeq \lambda r. \rintro{M}{\rintro{J'}{\rintro{K'}{\relim{l'.\rintro{K}{\relim{l.\varkey{K}{l}\varkey{K'}{l'}\varkey{J'}{l'}\varkey{M}{l}s}}}}}} \\
    &\defeq \lambda r. \rintro{M}{\rintro{J'}{\rintro{K'}{\relim{l.\varkey{K'}{l}\varkey{J'}{l}\varkey{M}{l}r}}}} \\
    ~\\
    \delta_{\rformu A} \circ \delta_A
    &:\defeq (\lambda s'. \rintro{J'}{\rintro{K'}{\relim{l'.\varkey{K'}{l'}\varkey{J'}{l'}s'}}}) \circ (\lambda s. \rintro{J}{\rintro{K}{\relim{l.\varkey{K}{l}\varkey{J}{l}s}}}) \\
    &\defeq \lambda s'. \rintro{J'}{\rintro{K'}{\relim{l'.\admkey{K'}{l'}\admkey{J'}{l'}\rintro{J}{\rintro{K}{\relim{l.\varkey{K}{l}\varkey{J}{l}s'}}}}}} \\
    &\defeq \lambda s'. \rintro{J'}{\rintro{K'}{\relim{l'.\rintro{J}{\rintro{K}{\relim{l.\varkey{K}{l}\varkey{J}{l}\varkey{K'}{l'}\varkey{J'}{l'}s'}}}}}} \\
    &\defeq \lambda s'. \rintro{J'}{\rintro{K'}{\rintro{K}{\relim{l.\varkey{K}{l}\varkey{K'}{l}\varkey{J'}{l}s'}}}}
  \end{align*}
  which up to $\alpha$-equivalence is the same as the previous.
\end{proof}
$\rformu$ is not typically idempotent, unless $\Tiny$ is a proposition
so that $\Tiny \to \Tiny \times \Tiny$ is an equivalence.
\fi
\subsection{Limits and Colimits}

We can show that, as a right adjoint, $\rform{}$ preserves pullbacks.
\begin{proposition}[$\rformsym$ preserves 1]
  $\rformu{1} \equiv 1$
\end{proposition}
\begin{proof}
  Any term $r : \rformu{1}$ will $\eta$-expand as
  $r \defeq \rintro{L}{r\substuck{i}{L}(\rbind{i})} \defeq
  \rintro{L}{\star}$ and so $\rformu{1}$ is contractible.
\end{proof}

\begin{proposition}[$\rformsym$ preserves $\Sigma$]\label{prop:root-preserve-sum}
  If $A : \univ$ and $B : A \to \univ$ are closed, then
  \begin{align*}
    \rformu \left( \sm{x : A} B(x) \right) \equiv \sm{x : \rformu A} \rformu B(\rget{x})
  \end{align*}
  Generally, if $A : \rformu \univ$ and
  $B : \rformu (\rget{A} \to \univ)$ there is an equivalence
  \begin{align*}
    \rformu \left( \sm{x : \rget{A}}\rget{B}(x) \right) \equiv \sm{x : \rformu \rget{A}} \rformu (\rget{B}(\rget{x}))
  \end{align*}
\end{proposition}
\begin{proof}
  Define maps either way by
  \begin{align*}
    r &\mapsto (\rintro{L}{\proj_1 \rget{r}}, \rintro{K}{\proj_2\rget{r}}) \\
    (s,t) &\mapsto \rintro{L}{\rget{s},\rget{t}}
  \end{align*}
\end{proof}

\begin{proposition}
  For any $A : \rformu{\univ}$ and $r, s : \rformu{\rget{A}}$, there
  is an equivalence
  \begin{align*}
    (r = s) \equiv \rformu \left( \rget{r} = \rget{s} \right)
    % \rform{L} \left( \prd{t : \Tiny} \varkey{L}{t} a(t) =
    %   \varkey{L}{t} a'(t) \right) \equiv \left(\rintro{L}{\lambda
    %   t. \varkey{L}{t} a(t)} =_{\rformu \prd{t : \Tiny}
    %   \varkey{L}{t} A(t)} \rintro{L}{\lambda t. \varkey{L}{t}
    %   a'(t)}\right)
  \end{align*}
\end{proposition}
\begin{proof}
  By the fundamental theorem of $\Idsym$-types, we just have to check
  that for fixed $r : \rformu{\rget{A}}$, the type
  \begin{align*}
    \sm{s : \rformu{\rget{A}}} \rformu \left( \rget{r} = \rget{s} \right)
  \end{align*}
  is contractible. By Proposition~\ref{prop:root-preserve-sum}, this
  type is equivalent to
  \begin{align*}
    \rformu{\left(\sm{x : \rget{A}} \rget{r} = x \right)}
  \end{align*}
  and the interior is a contractible pair. \mvrnote{Wait, do we need
    to check that $\rformsym$ preserves contractible types/equivalences?}
\end{proof}
This might look more familiar with the left side $\eta$-expanded:
\begin{corollary}[$\rformsym$ preserves $=$]
  $(\rintro{L}{\rget{r}} = \rintro{L}{\rget{s}}) \equiv \rform{L}
  \left( \rget{r} = \rget{s} \right)$
\end{corollary}
% \begin{corollary}[$\rformu$ preserves $=$]
%   If $A : \univ$ and $a,a' : A$ are closed then
%   \begin{align*}
%\left(\rintro{}{a} =_{\rformu A} \rintro{}{a'}\right) \equiv \rformu \left( a =_A a' \right)
%\end{align*}
%and more generally, if $A : \Tiny \to \univ$ and
% $a,a' : \prd{t : \Tiny} A(t)$ then
% \begin{align*}
%\left(\rintro{L}{\lambda t. \varkey{L}{t} a(t)} =_{\rformu \prd{t : \Tiny} \varkey{L}{t} A(t)} \rintro{L}{\lambda t. \varkey{L}{t} a'(t)}\right) \equiv \rform{L} \left( \prd{t : \Tiny} \varkey{L}{t} a(t) = \varkey{L}{t} a'(t) \right)
%\end{align*}
% \end{corollary}
% This is reminiscent of the same fact as for $\sharp$, but things are
% a bit weird because $\sharp$ is a monad and $\rformu$ is a comonad.
% \begin{proof}
%   \begin{align*}
%&\left(\rintro{L}{\lambda t. \varkey{L}{t} a(t)} =_{\rformu \prd{t : \Tiny} \varkey{L}{t} A(t)} \rintro{L}{\lambda t. \varkey{L}{t} a'(t)}\right) \\
%&\equiv \rform{K}{\left(\relim{k.\admkey{K}{k}\rintro{L}{\lambda t. \varkey{L}{t} a(t)}} =_{\prd{t : \Tiny} \varkey{L}{t} A(t)} \relim{k.\admkey{K}{k}\rintro{L}{\lambda t. \varkey{L}{t} a'(t)}}\right)} \\
%&\defeq \rform{K}{\left(\lambda t. \varkey{K}{t} a(t) =_{\prd{t : \Tiny} \varkey{L}{t} A(t)} \lambda t. \varkey{K}{t} a'(t) \right)}
%\end{align*}
%Going for the encode-decode strategy, let $\code $ be defined by
%\begin{align*}
%\code &: \rform{L}{(\prd{t : \Tiny} \varkey{L}{t}A(t))} \to \rform{L}{(\prd{t : \Tiny} \varkey{L}{t}A(t))} \to \univ \\
%\code(u,v) &:\defeq \rform{L} \left(\prd{t : \Tiny} \rget{u}(t) = \rget{v}(t)\right)
%\end{align*}
%so that
%\begin{align*}
%\code(\rintro{L}{\lambda t. \varkey{L}{t} a(t)}, \rintro{L}{\lambda t. \varkey{L}{t} a'(t)})
%&\defeq \rform{L} \left( \prd{t : \Tiny} \varkey{L}{t} a(t) = \varkey{L}{t} a'(t) \right)
%\end{align*}
%\begin{align*}
%\encode : \prd{u,v :\rform{L}{(\prd{t : \Tiny} \varkey{L}{t}A(t))}} (u = v) \to \code(u,v)
%\end{align*}
%\begin{align*}
%\decode : \prd{u,v : \rform{L}{(\prd{t : \Tiny} \varkey{L}{t}A(t))}} \code(u,v) \to (u = v)
%\end{align*}
% \end{proof}

\section{Transpension}\label{sec:transpension}

An equivalent characterisation of a tiny object in a 1-topos, due to
Freyd~\cite[Proposition 1.2]{yetter:tiny}, is an object $\Tiny$ such
that the dependent product functor
\begin{align*}
  \Pi_\Tiny : \mathcal{E}/\Tiny \to \mathcal{E}
\end{align*}
has a right adjoint $\nabla_\Tiny$. This operation was given the name \emph{transpension} in~\cite{dependable-atomicity, transpension}

If $\Tiny$ is tiny in the ordinary
sense, then in a 1-topos this adjoint can be defined by the
pullback
\[
  \begin{tikzcd}
    \Sigma_\Tiny \nabla_\Tiny B \ar[r] \ar[d] \arrow[dr, phantom, "\lrcorner", very near start] & \rformu B_\bot \ar[d, "\rformu \mathrm{supp}"] \\
    \Tiny \ar[r, "{(\chi_{\id_\Tiny})^\vee}" swap] & \rformu \Omega
  \end{tikzcd}
\]
where $B_\bot$ is the partial map classifier for $B$ and
$\mathrm{supp} : B_\bot \to \Omega$ is the canonical subobject
$B \rightarrowtail B_\bot$. These are defined by the dependent product
$\mathrm{true}^*(B \to 1)$ of the terminal map $B \to 1$ along
$\mathrm{true} : 1 \to \Omega$.

This construction doesn't do the right thing in HoTT, but we have
something similar: for $B : \rformu \univ$, define a type family
$\rdepform{-}{B} : \Tiny \to \univ$ by the pullback
\[
  \begin{tikzcd}
    \sm{t : \Tiny} \rdepform{t}{B} \ar[r] \ar[d] \arrow[dr, phantom, "\lrcorner", very near start] & \rformu \left(\sm{X : \univ} X \to \rget{B} \right) \ar[d, "\rformu \proj_1"] \\
    \Tiny \ar[r, "{(-=\id_\Tiny)^\vee}" swap] & \rformu \univ
  \end{tikzcd}
\]
where the map along the bottom is the transpose of
$(\lambda f. f = \id_\Tiny) : (\Tiny \to \Tiny) \to \univ$. By
function extensionality, this map is equal to
\begin{align*}
  t \mapsto \rintro{K}{\prd{s : \Tiny} t\substuck{s}{K} = s}
\end{align*}

Because $\rformu$ commutes with $\Sigma$, the map on the right is
equivalent to
\begin{align*}
  \proj_1 : \sm{X : \rformu \univ} \rform{K}{(\rget{X} \to \rget{B})} \to \rformu \univ
\end{align*}
The fibre of the pullback over a fixed $t : \Tiny$ is then easy to
calculate: it is the fibre of that $\proj_1$ over
$\rintro{K}{\prd{s : \Tiny} t\substuck{s}{K} = s}$.
\begin{align*}
  &\rform{L}{(\rget{X} \to \rget{B})}[\rintro{K}{\prd{s : \Tiny} t\substuck{s}{K} = s}/X] \\
  &\rform{L}{(X\substuck{l}{L}(\rbind{l}) \to \rget{B})}[\rintro{K}{\prd{s : \Tiny} t\substuck{s}{K} = s}/X] \\
  &\rform{L}{\left(\left( \rintro{K}{\prd{s : \Tiny} t\substuck{s}{K} = s} \right)\subkey{l}{L}(\rbind{l}) \to \rget{B} \right)} \\
  &\rform{L}{\left( \rintro{K}{\prd{s : \Tiny} t\substuck{l}{L}\substuck{s}{K} = s}(\rbind{l}) \to \rget{B} \right)} \\
  &\rform{L}{\left( (\prd{s : \Tiny} t\substuck{l}{L}\substuck{s}{K} = s)\sublock{K}{l} \to \rget{B} \right)} \\
  &\rform{L}{\left( (\prd{s : \Tiny} t\substuck{s}{L} = s) \to \rget{B} \right)}
\end{align*}
and so we take this as our definition.
\begin{definition}
  For $B : \rformu \univ$ and $t : \Tiny$, let
  \begin{align*}
    \rdepform{t}{B} :\defeq \rform{L}{\left( (\prd{s : \Tiny} t\substuck{s}{L} = s) \to \rget{B} \right)}
  \end{align*}
\end{definition}

The whole point of this construction was:
\begin{proposition}
  For $A : \Tiny \to \univ$ and $B : \rformu \univ$
  \begin{align*}
    \left(\prd{t : \Tiny} A(t) \to \rdepform{t}{B} \right) \equiv \rform{L} \left( \left(\prd{s : \Tiny} A\substuck{s}{L}(s)\right) \to \rget{B} \right)
  \end{align*}
\end{proposition}
\begin{proof}
  To apply dependent adjointness (Proposition~\ref{prop:dep-adj}) we
  need to massage the interior of the $\rform{L}$ a little. Define
  \begin{align*}
    &P : \left(\sm{t : \Tiny} A(t)\right) \to \rformu{\univ} \\
    &P(t,a) :\defeq \rintro{K}{(\prd{s:\Tiny} \varkey{K}{s} t = s) \to \rget{B}}
  \end{align*}
  so that
  \begin{align*}
    &\relim{i.(\admkey{L}{i}P)(\admkey{L}{i}(t,a))} \\
    &\defeq \relim{i.(\admkey{L}{i}(\lambda (t,a). \rintro{K}{(\prd{s:\Tiny} \varkey{K}{s} t = s) \to \rget{B}}))(\admkey{L}{i}(t,a))} \\
    &\defeq \relim{i.(\lambda (t,a). \rintro{K}{(\prd{s:\Tiny} \varkey{K}{s} t = s) \to \rget{(\varkey{L}{i}B)}})(\varkey{L}{i} t, \varkey{L}{i}a)} \\
    &\defeq \relim{i.\rintro{K}{(\prd{s:\Tiny} \varkey{K}{s} \varkey{L}{i} t = s) \to \rget{(\varkey{L}{i}B)}}} \\
    &\defeq (\prd{s:\Tiny} \varkey{L}{s} t = s) \to \rget{B}
  \end{align*}
  is exactly the interior of $\rform{L}$ in the definition of
  $\rdepform{t}{B}$.

  Then
  \begin{align*}
    &\prd{t : \Tiny} A(t) \to \rdepform{t}{B} \\
    &\equiv \prd{(t,a) : \sm{t : \Tiny} A(t)} \rdepform{t}{B} && \text{(Currying)} \\
    &\defeq \prd{(t,a) : \sm{t : \Tiny} A(t)} \rform{L}{\left((\prd{s : \Tiny} \varkey{L}{s} t = s) \to \rget{B}\right)} && \text{(Definition)} \\
    &\defeq \prd{(t,a) : \sm{t : \Tiny} A(t)} \rform{L}{\relim{i.(\admkey{L}{i}P)(\admkey{L}{i}(t,a))}} && \text{(Above calculation)} \\
    &\equiv \rform{L} \left(\prd{f:\prd{t':\Tiny} \sm{t : \Tiny} (\varkey{L}{t'}A)(t)} \relim{i.(\varkey{L}{i}P)(f(i))}\right) && \text{(Proposition~\ref{prop:dep-adj})} \\
    &\defeq \rform{L} \left(\prd{f:\prd{t':\Tiny} \sm{t : \Tiny} (\varkey{L}{t'}A)(t)} \left(\prd{s:\Tiny} \proj_1(f(i)) = s\right) \to \rget{B} \right)&& \text{(Definition of $P$)} \\
    &\equiv \rform{L} \left(\left(\prd{s:\Tiny}\sm{t : \Tiny} {a : (\varkey{L}{s}A)(t)} (t = s) \right)\to \rget{B} \right) && \text{(Univ. property of $\Sigma$)} \\
    &\equiv \rform{L} \left(\left(\prd{s:\Tiny} (\varkey{L}{s}A)(s)\right) \to \rget{B} \right) && \text{(Contractible pair)}
  \end{align*}
  is what we wanted to show.
\end{proof}

\begin{corollary}
  $\left(\prd{t : \Tiny} \rdepform{t}{B} \right) \equiv \rformu
  \rget{B}$
\end{corollary}
\begin{proof}
  Plug in $A \defeq \const_1$ in the above.
\end{proof}


% \begin{lemma}
%   If $0 : \Tiny$ then
%   $((\Tiny \to A) \to B) \equiv (A \to \rform{?} B)$
% \end{lemma}
% \begin{proof}
%   Suppose $f : ((\Tiny \to A) \to B)$, can start with
%   $\lambda a. \rintro{L}{?}$, but now we are stuck. We want to use
%   $f$ but it is locked, and we don't have a $t : \Tiny$ to let us
%   use it.
%
%   So let's just say $f$ is a closed term. Then we are unstuck:
%   \begin{align*}
%\mathsf{form}(f) :\defeq \lambda a. \rintro{L}{ (\varkey{L}{0} f)(\lambda t. \varkey{L}{t} a)} : (A \to \rform{?} B)
%\end{align*}
%
%If $g : (A \to \rform{?} B)$, then can define
%\begin{align*}
%\mathsf{function}(g) :\defeq \lambda h. \relim{i. g(h(i))} : ((\Tiny \to A) \to B)
%\end{align*}
%without needing $g$ to be closed.
%
%Now to try round trips. For this we do need $g$ to be closed or
% composing doesn't make sense.
% \begin{align*}
%&\mathsf{form}(\mathsf{function}(g))  \\
%&\defeq \lambda a. \rintro{L}{ (\varkey{L}{0} (\mathsf{function}(g)))(\lambda t. \varkey{L}{t} a)} \\
%&\defeq \lambda a. \rintro{L}{ (\mathsf{function}(\varkey{L}{0} g))(\lambda t. \varkey{L}{t} a)} \\
%&\defeq \lambda a. \rintro{L}{ (\lambda h. \relim{i. (\varkey{L}{0} g)(h(i))})(\lambda t. \varkey{L}{t} a)} \\
%&\defeq \lambda a. \rintro{L}{ \relim{i. (\varkey{L}{0} g)((\lambda t. \varkey{L}{t} a)(i)))}} \\
%&\defeq \lambda a. \rintro{L}{ \relim{i. (\varkey{L}{0} g)(\varkey{L}{i} a)}}
%\end{align*}
%And the other:
%\begin{align*}
%&\lambda h. \relim{i. (\lambda a. \rintro{L}{ f(\lambda t. \varkey{L}{t} a)})(h(i))} \\
%&\defeq \lambda h. \relim{i. \rintro{L}{ f(\lambda t. \varkey{L}{t} (h(i)))}}\\
%&\defeq \lambda h. \relim{i. \rintro{L}{ f(\lambda t. \varkey{L}{t} h(\varkey{L}{t} i))}}\\
%&\defeq \lambda h. f(\lambda t. \varkey{L}{t} h(\varkey{L}{t} i))[\sublock{L}{i}]\\
%&\defeq \lambda h. f(\lambda t. h(t))\\
%&\defeq \lambda h. f(h) \\
%&\defeq f
%\end{align*}
% \end{proof}

% If we try to make rules for this directly and build in the required
% substitutions, we get something horrible like
% \begin{mathpar}
%   \inferrule*[left=$\surd$-intro]{\Gamma, \ctxlock{L} \yields B
%   \type \and \Gamma \yields t : \Tiny}{\Gamma \yields
%   \rdepform{t}{B} \type} \and \inferrule*[left=$\surd$-intro]{\Gamma
%   \yields t' : \Tiny \and \Gamma, \ctxlock{L} \yields t : \Tiny \and
%   \Gamma, \ctxlock{L} \yields a : A(t) \and \Gamma, \ctxlock{L}, f :
%   \prd{t : \Tiny} A \yields b : B}{\Gamma \yields
%   \rintro{L}{f.b,t,a} : \rdepform{t}{B}} \and
%   \inferrule*[left=$\surd$-elim]{\Gamma, i : \Tiny \yields r :
%   \rdepform{i}{B}}{\Gamma \yields \relim{i.r} : B}
% \end{mathpar}
% where we need \emph{two} terms of $\Tiny$ in the intro rule, one to
% use in the function $f$, and the second to get past the resulting
% lock in the conclusion.

A surprising fact is that the pullback of $\Tiny$ to any slice
$\mathcal{E}/X$ is itself also tiny~\cite[Theorem 1.4]{yetter:tiny},
but crucially, the right adjoint $\rformsym$ is not preserved by
pullback.

Instead, the right adjoint $\surd_{/X}$ on an object
$D \to X$ can be calculated by the pullback
\[
  \begin{tikzcd}
    \Sigma_X \surd_{/X} \ar[r] \ar[d] & \rformu (\Sigma_{\Tiny \to X} \Pi_c D) \ar[d, "\rformu \Pi_c D"] \\
    X \ar[r, "\eta" swap] & \rformu (\Tiny \to X)
  \end{tikzcd}
\]
where $c : X \to (\Tiny \to X)$ is the transpose of the projection
$X \times \Tiny \to X$, and the $\rformsym$ on the right is the global
adjoint to $(\Tiny \to -)$.

Let us describe this internally. Suppose $X$ is a closed
type. Switching perspective from the slice over $X$ to type families
over $X$, we first calculate the dependent product of a type family
$D : X \to \univ$ along the map $c : X \to (\Tiny \to X)$. This is

\begin{align*}
  \sm{f : \Tiny \to X} (\prd{x' : X} (c(x') = f) \to D(x'))
\end{align*}
with the first projection down to $\Tiny \to X$. We now need to apply
$\rformsym$. Similar to transpension, because
$\rformsym$ commutes with pullbacks this is
\begin{align*}
  \sm{f : \rform{L}{\Tiny \to X}} \rform{L}{\left(\prd{x' : X} (c(x') = (f\substuck{i}{L})(\rbind{i})) \to D(x')\right)}
\end{align*}
To pull back along $\eta$ and calculate the fibre over $x : X$, we can
simply substitute:

\begin{align*}
  &\rform{L}{\left(\prd{x' : X} (c(x') = (\eta(x)\substuck{i}{L})(\rbind{i})) \to D(x')\right)} \\
  \equiv &\rform{L}{\left(\prd{x' : X} (c(x') = (\eta(x\substuck{i}{L}))(\rbind{i})) \to D(x')\right)} \\
  \equiv &\rform{L}{\left(\prd{x' : X} (c(x') = (\rintro{K}{\lambda k. x\substuck{i}{L}\substuck{k}{K}}))(\rbind{i})) \to D(x')\right)} \\
  \equiv &\rform{L}{\left(\prd{x' : X} (c(x') = (\lambda k. x\substuck{i}{L}\substuck{k}{K}\subkey{i}{K}) \to D(x')\right)} \\
  \equiv &\rform{L}{\left(\prd{x' : X} (c(x') = (\lambda k. x\substuck{k}{L}) \to D(x')\right)} \\
  \equiv &\rform{L}{\left(\prd{x' : X} \left( \prd{k : \Tiny} (x' = x\substuck{k}{L})\right) \to D(x')\right)} \\
\end{align*}

\iffalse
\section{$\Tiny$-discreteness}
\begin{definition}
  A type $A : \univ$ is \emph{$\Tiny$-discrete} if the weakening map
  $A \to (\Tiny \to A)$ is an equivalence.
\end{definition}

\mvrnote{In \cite{yetter:tiny} it is proven that $\Tiny$-discrete
  objects form a reflective and coreflective subcategory, at least in
  the 1-topos case. Does it work here? We can use a nullification HIT
  to build the reflection, but I can't get that to be equivalent to
  the coequaliser definition in Yetter}
\fi


\section{Tiny Objects and Models of Cubical Type Theory}

\newcommand{\Set}{\mathsf{Set}}
\newcommand{\El}{\mathsf{El}}
\newcommand{\univfib}{\mathsf{U}}
\newcommand{\Int}{\mathbb{I}}
\newcommand{\isFib}{\mathsf{isFib}}
\newcommand{\Fib}{\mathsf{Fib}}
\newcommand{\Compstr}{\mathsf{C}}

Let us repeat the construction of \cite[Theorem 5.2]{lops}, and see to
what extent things compute better.

The ambient type theory is intensional, predicative Martin-L\"of Type
Theory, with function extensionality and UIP: we therefore denote the
ambient universe $\Set$ rather than $\univ$, and aim to construct a
new universe $\univfib$ that classifies fibrations. We also have an
interval type $\Int$, which is assumed to be tiny.

The main piece of input data is a \emph{notion of composition
  structure}, which is a function $\Compstr : (\Int \to \Set) \to \Set$ that
parameterises the notion of fibration. There are some derived structures:
\begin{align*}
  \isFib &: (\Gamma : \Set)(A : \Gamma \to \Set) \to \Set \\
  \isFib(\Gamma)(A) &:\defeq \prd{p : \Int \to \Gamma} \Compstr(A \circ p) \\
  \Fib &: \Set \to \Set \\
  \Fib(\Gamma) &:\defeq \sm{A : \Gamma \to \Set} \isFib(\Gamma)(A)
\end{align*}

The original construction is done in crisp type theory, with an
interval asserted to be tiny via the crisp adjunction
\begin{align*}
  \flat((\Int \to A) \to B) \equiv \flat(A \to \rformu{B})
\end{align*}
The types in our construction will be a little different: the
$\rformu$ former itself is used to guard the adjunction, as we saw in
\ref{?}.

\begin{theorem}

\end{theorem}
\begin{proof}
  The construction proceeds the same way as in \cite{lops}. The
  universe classifying fibrations is constructed by the pullback
  \[
  \begin{tikzcd}
    \univfib \ar[r] \ar[d] \arrow[dr, phantom, "\lrcorner", very near start] & \rformu \sm{A : \Set} A \ar[d, "\rformu \proj_1"] \\
    \Set \ar[r, "\Compstr^\vee" swap] & \rformu \Set
  \end{tikzcd}
  \]
  By definition,
  \begin{align*}
    \Compstr^\vee(X) :\defeq \rintro{L}{\Compstr(\lambda j. X\substuck{j}{L})}
  \end{align*}

  For the third time in this note, we calculate a pullback directly by
  commuting $\rformsym$ with $\Sigma$ and substituting.
  \begin{align*}
    \univfib
    &:\defeq \sm{X : \Set} \rformu{\rget{A}} [\Compstr^\vee(X)/A] \\
    % &\defeq \sm{X : \Set} \rformu{(A\substuck{i}{L})(\rbind{i})} [\Compstr^\vee(X)/A] \\
    % &\defeq \sm{X : \Set} \rform{K}{(\Compstr^\vee(\substuck{i}{K}))(\rbind{i})} \\
    &\defeq \sm{X : \Set} \rform{L}{\Compstr(\lambda j. X\substuck{j}{L})}
  \end{align*}

  The projection maps in the original pullback square correspond to
  \begin{align*}
    &\pi_1 : \univfib \to \Set \\
    &\pi_1(X, r) :\defeq X \\
    &\pi_2 : \univfib \to \rformu \sm{A : \Set} A \\
    &\pi_2(X, r)(\lock{L}) :\defeq (\Compstr(\lambda j. X\substuck{j}{L}), \rget{r})
  \end{align*}

  The map $\pi_2$ can be transposed back to
  \begin{align*}
    \pi_2{}_\vee
    &: (\Int \to \univfib) \to \sm{A : \Set} A \\
    \pi_2{}_\vee(p)
    &:\defeq \pi_2(p(k), \rbind{k}) \\
    &\defeq \pi_2(\proj_1 p(k), \proj_2 p(k), \rbind{k}) \\
    &\defeq (\Compstr(\lambda j. (\proj_1 p(k))\subkey{j}{L}), \rget{(\proj_2 p(k))})\sublock{L}{k} \\
    &\defeq (\Compstr(\lambda j. \proj_1 p(j)), (\proj_2 p(i))(\rbind{i}))
  \end{align*}
  And so we have a completely explicit definition of $\El$ for $\univfib$:
  \begin{align*}
    \El &: \Fib \univfib \\
    \El &:\defeq (\pi_1, \lambda p. (\proj_2 p(i))(\rbind{i}))
  \end{align*}

  It remains to define
  \begin{align*}
    \code : \prd{\Gamma : \rformu \Set}{\Phi : \rformu \Fib \Gamma} \Gamma \to \univfib
  \end{align*}
  So suppose we have
  \begin{align*}
    \Gamma &: \rformu \Set \\
    \Phi &: \rformu \sm{\rget{\Gamma} \to \Set} \prd{p : \Int \to \rget{\Gamma}} \Compstr(A \circ p)
  \end{align*}
  (so that $\Phi \defeq (A, \alpha)$).
\end{proof}


\mvrnote{Maybe we should change the definition of $\Fib$!} The natural thing would be to set
\begin{align*}
  \Fib(\Gamma) :\defeq \sm{A : \Gamma \to \Set}
  \rform{L}{\left(\prd{p : \prd{i : \Int} \Gamma\substuck{i}{L}}
  \Compstr(\lambda i. (A\substuck{i}{L})(p(i)))\right)}
\end{align*}
And then the classifying property of $\univfib$ holds for any
$\Gamma$ at all, not just crisp ones! Is this good for anything?

But in fact we can simplify further...

\begin{definition}
  The type of \emph{fibration structures} on (any!) type $A$ is
  \begin{align*}
    \isFib(A) :\defeq \rform{L}{\Compstr(\lambda i. A\substuck{i}{L})}
  \end{align*}
\end{definition}

And define $\univfib :\defeq \sm{A : \Set} \isFib(A)$. Let's silently coerce a term $A : \univfib$ to $A : \Set$ by first projection.

\subsection{CCHM}
\label{sec:cchm}

\newcommand{\cof}{\mathsf{cof}}
\newcommand{\Cof}{\mathsf{Cof}}
\newcommand{\CCHMcomp}{\mathsf{CCHM}}
\newcommand{\Fill}{\mathsf{Fill}}
\newcommand{\extrel}{{\nnearrow}}

Now recall the \emph{CCHM composition structure}. For the definition
we need a couple of additions to the theory:
\begin{align*}
  0, 1 : \Int \\
  \cof : \Set \to \Set \\
\end{align*}

The extension relation is defined by
\begin{align*}
f \extrel x :\defeq (u : \varphi) \to (f(u) = x)
\end{align*}

\begin{definition}
  \begin{align*}
    \CCHMcomp &: (\Int \to \Set) \to \Set \\
    \CCHMcomp(P) &:\defeq (\varphi : \Cof)(p : (i : \Int) \to \varphi \to P(i)) \to
                   \left( \sm{a_0 : P(0)} p(0) \extrel a_0 \right) \to
                   \left( \sm{a_0 : P(1)} p(1) \extrel a_1 \right)
  \end{align*}
\end{definition}

The derived notion of filling can be defined
\begin{align*}
  \Fill(A) &: (\Int \to \Set) \to \Set \\
  \Fill(A) &:\defeq (\varphi : \Cof)(f : (i : \Int) \to \varphi \to A(i))
             (a : \sm{a' : A(0)} f(0) \extrel a') \to
             \sm{g : (i : \Int) \to P(i)} f \extrel g \times g(0) = a
\end{align*}

But we might want something different.



\begin{lemma}
  Given $A : \Set$ and $\isFib(A)$, \mvrnote{from comp to fill}
\end{lemma}

\begin{proposition}
  If $A_1 : \univfib$ and $A_2 : A_1 \to \univfib$, there is a
  fibration structure $\isFib\left( \sm{x : A_1} A_2(x) \right)$.
\end{proposition}
\begin{proof}

\end{proof}

\section{Tiny Objects in Synthetic Differential Geometry}

\iffalse
\section{Path Types}
  \newcommand{\coe}{\mathsf{coe}} \newcommand{\coh}{\mathsf{coh}}
  \newcommand{\OTO}{\mathsf{IsOTO}} \newcommand{\oto}{\mathsf{oto}}

  I am strongly reminded of~\cite[Section
  2.3]{altenkirch-kaposi:without-interval}, whose $\Gamma^=$ looks an
  awful lot like our $\Gamma, \lock$ supposing two points
  $0, 1 : \Tiny$, and whose `logical relation at a type' looks an
  awful lot like a pair of maps
  \begin{align*}
    (-)^{*T} &: \prd{A:\univ} \rform{L}\left(\varkey{L}{0}A \to \varkey{L}{1}A \to \univ\right) \\
    (-)^{*t} &: \prd{\{A:\univ\}} {a : A}  \rform{L}\left((\rget{A})^{*T}(\varkey{L}{0}a,\varkey{L}{1}a)\right)
  \end{align*}
  (where $A : \univ$ is implicit in the second map) or combining them
  into one map
  \begin{align*}
    (-)^* &: \prd{\{A:\univ\}} {a : A} \rform{L}\left(\rget{(\univ^*(A))}(\varkey{L}{0}a,\varkey{L}{1}a)\right)
  \end{align*}
  relying on the definition
  \begin{align*}
    \univ^* :\defeq \rintro{L}{\lambda A. \lambda B. A \to B \to \univ}
  \end{align*}

  \subsection{IsEquiv}

  Following~\cite[Section 2.8]{altenkirch-kaposi:without-interval},
  what we really want is for paths in $\univ$ to be equivalences. We
  instead want something like
  \begin{align*}
    (-)^* &: \prd{\{A:\univ\}} {a : A} \rform{L}\left(\proj_1 \rget{(\univ^*(A))}(\varkey{L}{0}a,\varkey{L}{1}a)\right) \\
    \univ^* &:\defeq \rintro{L}{\lambda A.\lambda B. \sm{R: A \to B \to \univ} \prd{a : A} \isContr(\sm{b : B} R(a,b)) \times \prd{b : B} \isContr(\sm{a : A} R(a,b))}
  \end{align*}
  The actual $\univ^*$ that they use is, for all $A,B : \univ$, the
  iterated $\Sigma$ of
  \begin{align*}
    R &: A \to B \to \univ \\
    \coe^0 &: A \to B \\
    \coh^0 &: \prd{x:A} R(x, \coe^0 x) \\
    \coe^1 &: B \to A \\
    \coh^1 &: \prd{y : B} R(\coe^1 y, y) \\
      &\dots
  \end{align*}
  (plus a couple more fields)

  The hard one in that paper is $\Pi$-types, so let's skip to trying
  to define $(A \to B)^*$ for $A,B : \univ$. Under a lock
  $\ctxlock{L}$ we have to produce
  \begin{align*}
    (A \to B)^* &: (\varkey{L}{0}A \to \varkey{L}{0}B)\to (\varkey{L}{1}A \to \varkey{L}{1}B) \to \univ \\
    \coe^0 &: (\varkey{L}{0}A \to \varkey{L}{0}B)\to (\varkey{L}{1}A \to \varkey{L}{1}B) \\
    \coh^0 &: \prd{f : \varkey{L}{0}A \to \varkey{L}{0}B} R(f, \coe^0 f) \\
    \coe^1 &: (\varkey{L}{1}A \to \varkey{L}{1}B) \to (\varkey{L}{0}A \to \varkey{L}{0}B)  \\
    \coh^1 &: \prd{g : \varkey{L}{1}A \to \varkey{L}{1}B } R(\coe^1 g, g)
  \end{align*}
  The relation is defined is defined by pointwise relatedness:
  \begin{align*}
    (A \to B)^*(f_0, f_1) :\defeq \prd{x_0 : \varkey{L}{0}A}{x_1 : \varkey{L}{1}A}{r : \rget{(A^*)}(x_0, x_1)} \rget{(B^*)}(f_0(x_0), f_1(x_1))
  \end{align*}
  The $\coe$ can be defined easily
  \begin{align*}
    \coe^0(f_0,a_1) :\defeq \rget{(\coe^0_B)}(f_0(\rget{(\coe^1_A)}(a_1)))
  \end{align*}
  and now $\coh$ is the interesting one, but here we get stuck.

  We can sort of define filling the `top' of a box for any $A : \univ$
  \begin{align*}
    \mathsf{top}_A &: \rform{L} \left(\prd{x_0 : \varkey{L}{0}A}{x_1 : \varkey{L}{1}A} \rform{K} \left( (\relim{i. \varkey{K}{0} \varkey{L}{i} A^*})(\varkey{K}{0}x_0, \varkey{K}{0} x_1) \to (\relim{i. \varkey{K}{1} \varkey{L}{i} A^*})(\varkey{K}{1}x_0, \varkey{K}{1} x_1) \right) \right) \\
    \mathsf{top}_A &:\defeq \rintro{L}{\lambda x_0. \lambda x_1. \rintro{K}{\relim{k.\coe^0_{(\relim{i. \varkey{K}{k}\varkey{L}{i} A^*})(\varkey{K}{k}x_0,\varkey{K}{k}x_1)}}}}
  \end{align*}
  But this isn't enough, we need to allow arbitrary relations for
  $x_0$ and $x_1$, not just `refl'. And here we truly are stuck,
  because we don't have a substitution roughly like
  $x_0, x_1, R(x_0, x_1) \yields x, \ctxlock{L}$.

  Would need a backwards map
  \begin{align*}
    ? &: \prd{A:\univ} \rform{L}\left(\sm{x_0 : \varkey{L}{0}A}{x_1 : \varkey{L}{1}A} \rget{A^*}(x_0, x_1) \to \prd{t:\Tiny} \varkey{L}{t}A \right)
  \end{align*}
  that computes, is such a thing reasonable? This is feeling not good.

  \subsection{OTO}

  Mike had a different suggestion in his MURI talk for how the
  relation on $\univ$ should work. I am going to try and write this
  using a $\rformu$. For a relation $R : A \to B \to \univ$,
  coinductively $\OTO(R)$ has destructors
  \begin{align*}
    \OTO(R) &\to \left(\prd{a : A} \sm{b : B} R(a,b)\right) \times \left(\prd{b : B} \sm{a : A} R(a,b)\right) \\
    % \OTO(R) &\to \rform{L} \prd{a_0 : \varkey{L}{0}A}{b_0 : \varkey{L}{0}B}{r_0 : (\varkey{L}{0}R)(a_0,b_0))}{a_1 : \varkey{L}{1}A}{b_1 : \varkey{L}{1}B}{r_1 : (\varkey{L}{1}R)(a_1,b_1))} \\
    % &\quad\quad\quad \OTO\left(\lambda a_2. \lambda b_2. (\proj_1
    %   \rget{R^*}(a_0, a_1, a_2)(b_0,b_1,b_2))(r_0,r_1)\right)
\OTO(R) &\to \prd{a : A}{b : B}{r : R(a,b)} \rform{L} \OTO\left(\relim{i.(\varkey{L}{i}R)^*}\right)
\end{align*}
This relies on the definition of $\univ^*$ and $(A \to B)^*$ being the ones below.

Let's name things in a similar way to the cubical paper, and call $R$ and the non-recursive fields of $\OTO(R)$
\begin{align*}
\coe &: A \to B \\
\coh &: \prd{x:A} \Id(x, \coe x) \\
\coe^{-1} &: B \to A \\
\coh^{-1} &: \prd{y : B} \Id(\coe^{-1} y, y)
\end{align*}
and, the recursive one, say
\begin{align*}
\partial R(\ctxlock{L}, a_0, b_0, r_0, a_1, b_1, r_1) : \OTO\left(\lambda a_2. \lambda b_2. (\proj_1 \rget{R^*}(a_0, a_1, a_2)(b_0,b_1,b_2))(r_0,r_1)\right)
\end{align*}
And let's also give a name to the first component of $\univ^*$:
\begin{align*}
\Id &: \prd{A : \univ} \rform{L}\left(\varkey{L}{0}A \to \varkey{L}{1}A \to \univ \right)
\end{align*}
so that for an ordinary term $a : A$,
\begin{align*}
a^* : \rform{L} \Id_A(\ctxlock{L}, \varkey{L}{0}a, \varkey{L}{1}a)
\end{align*}

Now the actual definitions:  (using the pattern-matching notation)
\begin{align*}
\Id_\univ(\ctxlock{L},A,B) &:\defeq \sm{R : A \to B \to \univ} \OTO(R) \\
\coe_\univ(\ctxlock{L}) &: \univ \to \univ \\
\coe_\univ(\ctxlock{L}) &:\defeq \id_\univ \\
\coh_\univ(\ctxlock{L}) &: \prd{A : \univ} \sm{R : A \to A \to \univ} \OTO(R) \\
\coh_\univ(\ctxlock{L}, A) &:\defeq (\rget{\Id_A}, \coe_A, \dots) \\
%\partial_\univ(\ctxlock{L},\ctxlock{K}, A_0, B_0, r_0, A_1, B_1, r_1) &:
\end{align*}
Now let's think about the recursive field. We at least need
\begin{align*}
\partial\coe_\univ(\ctxlock{L},\ctxlock{K}, A_0, B_0, r_0, A_1, B_1, r_1, a_2, b_2) &: ?
\end{align*}
where
\begin{align*}
A_0, B_0, A_1, B_1 &: \univ \\
r_0 &: \Id_\univ(A_0, B_0) \\
r_1 &: \Id_\univ(A_1, B_1) \\
a_2 &: \Id_\univ(A_0, A_1) \\
b_2 &: \Id_\univ(B_0, B_1)
\end{align*}


\begin{align*}
\Id_{\prd{x:A}B(x)}(\ctxlock{L}) &: \prd{x:\varkey{L}{0}A} \varkey{L}{0} B(x) \to \prd{x:\varkey{L}{1}A} \varkey{L}{1} B(x) \to \univ \\
\Id_{\prd{x:A}B(x)}(\ctxlock{L}, f_0, f_1) &:\defeq \prd{p : \prd{i:\Tiny} \varkey{L}{i} A} \Id_{B?}(\ctxlock{L}, f_0(p(0)), f_1(p(1))) \\
\coe_{\prd{x:A}B(x)}(\ctxlock{L}) &: \prd{x:\varkey{L}{0}A} \varkey{L}{0} B(x) \to \prd{x:\varkey{L}{1}A} \varkey{L}{1} B(x) \\
\coe_{\prd{x:A}B(x)}(\ctxlock{L},f_0,a_1) &:\defeq \coe_{B?}(f_0(\coe_A^{-1}(a_1))) \\
\coh_{\prd{x:A}B(x)}(\ctxlock{L}) &: \prd{f : \prd{x:\varkey{L}{0}A} \varkey{L}{0} B(x)} \Id_{\prd{x:A}B(x)}(\ctxlock{L}, f, \coe_{\prd{x:A}B(x)}(\ctxlock{L}, f)) \\
\coh_{\prd{x:A}B(x)}(\ctxlock{L}, f, p) &:\defeq ? \\
(\lambda x. b)^*(\ctxlock{L}) &: \prd{p : \prd{i:\Tiny} \varkey{L}{i} A} \Id_{B?}(\ctxlock{L}, (\varkey{L}{0}b)[p(0)/x], (\varkey{L}{1}b)[p(1)/x]) \\
(\lambda x. b)^*(\ctxlock{L},p) &:\defeq \relim{i.((\varkey{L}{i}b)[p(i)/x])^*} \\
(f(a))^*(\ctxlock{L}) &:\defeq f^*(\ctxlock{L},\lambda i. \varkey{L}{i} a)
\end{align*}


\begin{align*}
(\code(\Sigma_A B) : \univ)^*(\ctxlock{L}) &:\defeq ? \\
\end{align*}

OLD: This relies on the definition of $(A \to B)^*$ being pointwise relatedness, so that $\rget{R^*}$ has type
\begin{align*}
\rget{R^*} &: \prd{a_0 : \varkey{L}{0}A}{a_1 : \varkey{L}{1}A}{a_2 : \rget{A^*}(a_0,a_1)}{b_0 : \varkey{L}{0}B}{b_1 : \varkey{L}{1}B}{b_2 : \rget{B^*}(b_0,b_1)}  \\
&\qquad (\univ^*)((\varkey{L}{0} R)(a_0,b_0), (\varkey{L}{1} R)(a_1,b_1))
\end{align*}
and we have also already chosen
\begin{align*}
(\univ^*)((\varkey{L}{0} R)(a_0,b_0), (\varkey{L}{1} R)(a_1,b_1)) :\defeq
\sm{S : (\varkey{L}{0} R)(a_0,b_0) \to (\varkey{L}{1} R)(a_1,b_1) \to \univ} \dots
\end{align*}
and so we have to project out that first part so that we can evaluate it at $(r_0,r_1)$.

Actually now $\rget{R^*}$ has type
\begin{align*}
\rget{R^*} &: \prd{a : \prd{i:\Tiny} \varkey{L}{i} A}{b : \prd{i:\Tiny} \varkey{L}{i} B}  \\
&\qquad \proj_1 \Id_{\univ}((\varkey{L}{0} R)(a(0),b(0)), (\varkey{L}{1} R)(a(1),b(1)))
\end{align*}

\mvrnote{Well, now I'm stuck again. The only idea I have left is to build in endpoints into the context $\ctxlock{L}$ somehow, maybe following the altenkirch/kamposi idea. (and change the type rules).}

% \mvrnote{I had to change the definition of $\Id_{\prd{x:A}B(x)}(\ctxlock{L}, f_0, f_1) $ because I was getting stuck when defining $(\lambda x. b)^*$. The old way, where you use a relation between $a0$ and $a1$, there does not appear to be any way to construct the $\Id$ in $B$. There is nothing you can substitute for $x$ in $b$, because you only have the endpoints}


%\subsection{Directed}
%It might be easier to try a directed thing first.

%Unfolding definitions it has type
%\begin{align*}
%\coh^0 : \prd{f_0 : \varkey{L}{0}A \to \varkey{L}{0}B} \prd{x_0 : \varkey{L}{0}A}{x_1 : \varkey{L}{1}A}{r : \rget{(R_A)}(x_0, x_1)} \rget{(R_B)}(f_0(x_0), \rget{(\coe^0_B)}(f_0(\rget{(\coe^1_A)}(x_1))))
%\end{align*}
%\begin{align*}
%\coh^0(f_0,x_0,x_1,r) :\defeq ?? \rget{(\coh^0_B)}(f_0(\rget{(\coe^1_A)}(x_1)))
%\end{align*}
%Suppose we have $A : \univ$ and $B : A \to \univ$. (Just letting $x : A \yields B : \univ$ as a term will confuse me).
%\begin{align*}
%R &: \left(\prd{x : \varkey{L}{0}A}(\varkey{L}{0}B)(x)\right)\to \left(\prd{x : \varkey{L}{1}A}(\varkey{L}{1}B)(x)\right) \to \univ \\
%\coe^0 &: \left(\prd{x : \varkey{L}{0}A}(\varkey{L}{0}B)(x)\right) \to \left(\prd{x : \varkey{L}{1}A}(\varkey{L}{1}B)(x)\right) \\
%\coh^0 &: \prd{f : \prd{x : \varkey{L}{0}A}(\varkey{L}{0}B)(x)} f \sim \coe^0 f \\
%\coe^1 &: \left(\prd{x : \varkey{L}{1}A}(\varkey{L}{1}B)(x)\right) \to \left(\prd{x : \varkey{L}{0}A}(\varkey{L}{0}B)(x)\right) \\
%\coh^1 &: \prd{g : \prd{x : \varkey{L}{1}A}(\varkey{L}{1}B)(x)} \coe^1 g \sim g
%\end{align*}

%Then define $\Idsym_A(a,a') :\defeq \relim{\_.A^{*T}}(a,a')$ and $\refl{a} :\defeq \relim{\_.a^{*t}}$. Their stuck $\mathsf{R} : \Gamma \to \Gamma^=$ are admissible for us: it is just the transpose of weakening, which corresponds to ignoring the new variable in $\relim{i.a}$.

%\section{Extension Types?}
%\newcommand{\syn}{\mathsf{syn}}
%\newcommand{\Op}{\fullmoon}
%In Jon's Synthetic Tait Computability stuff, the $\syn$ proposition is tiny. The extension types also frequently use $\syn$ as the proposition where the term is fixed. Is this a coincidence? Can we make $\Op - :\defeq (\syn \to -)$ `compute' the same way $\Idsym$-types are supposed to commute?
%
%Suppose we do something similar to the above and have maps
%\begin{align*}
%(-)^{\Op T} &: \prd{A:\univ} \rform{L}\left(\sm{R : \univ} (\syn \to A \equiv R)\right) \\
%(-)^{\Op t} &: \prd{A:\univ} A \to \rform{L}\left(\proj_1 \rget{(A^{\Op T})}\right)
%\end{align*}
%where $\relim{\_.\proj_1 A^{\Op T}} : \univ$ is supposed to be what $A$ reduces to when $\syn$ holds. Again this can be given as one map
%\begin{align*}
%(-)^{\Op} &: \prd{A:\univ} A \to \rform{L}\left(\proj_1 \rget{\univ^{\Op}(A)}\right)
%\end{align*}
%if we define $\univ^{\Op}(A) :\defeq \sm{R : \univ} (\syn \to A \equiv R)$.
%
%\mvrnote{Is this going anywhere?}

%Type former for extension types might have shape
%\begin{align*}
%Ext : \prd{A : \syn \to \univ} \prd{s : \syn} A(s) \to \univ
%\end{align*}
%so $Ext(A)(a)$ is the type of terms that are exactly $a$ when $\syn$ holds.
%
%But that type rearranges to
%\begin{align*}
%\prd{A : \syn \to \univ} \prd{s : \syn} A(s) \to \univ
%&\equiv \left(\syn \to \sm{A : \univ} A\right) \to \univ \\
%&\equiv \left(\sm{A : \univ} A\right) \to \rformu \univ \\
%&\equiv \prd{A : \univ} (A \to \rformu \univ)
%\end{align*}
%This is equivalent to $\prd{A : \univ} \rformu ((\syn \to A) \to \univ)$ if that helps.

%Is this now suitable as a destructor for the universe? Just using $\prd{A : \univ} (\syn \to A) \to \univ$ is another candidate, but maybe it is important that $A$ is also restricted to $\syn$?

%\section{No Labels?}
%Can we somehow fold the $i: \Tiny$ variable into the lock label?
%
%\begin{mathpar}
%\inferrule*[left=ctx-lock]{\Gamma \ctx}{\Gamma, \ctxlocke{i} \ctx} \\
%\inferrule*[left=counit,fraction={-{\,-\,}-}]{\Gamma, \ctxlocke{i}, \Gamma' \yields t : \Tiny \and \Gamma \yields a : A}{\Gamma, \ctxlocke{i}, \Gamma' \yields \varkeye{i}{t} a : \varkeye{i}{t} A} \and
%\inferrule*[left=unit,fraction={-{\,-\,}-}]{\Gamma, i : \Tiny, \ctxlocke{i} \yields a : A}{\Gamma \yields a[\sublock{}{i}] : A[\sublock{}{i}]}
%\end{mathpar}
%\begin{mathpar}
%%\inferrule*[left=var-option-1]{n \defeq |{\mathsf{locks}(\Gamma')}| \\\\
%%\Gamma, x : A, \Gamma' \yields t_i : \Tiny \text{ for } i \in [1,n]
%%}{\Gamma, x : A, \Gamma' \yields \varkeye{t_n} \dots \varkeye{t_1} x : \varkeye{t_n} \dots \varkeye{t_1} A} \and
%\inferrule*[left=var]{
%\Gamma, x : A, \Gamma'_{>i_i} \yields t_i : \Tiny \text{ for } i_i \in \mathsf{locks}(\Gamma')
%}{\Gamma, x : A, \Gamma' \yields \varkeye{i_n}{t_n} \dots \varkeye{i_1}{t_1} x : \varkeye{i_n}{t_n} \dots \varkeye{i_1}{t_1} A} \and
%\end{mathpar}
%\begin{mathpar}
%\inferrule*[left=$\surd$-intro]{\Gamma, \ctxlocke{i} \yields A \type}{\Gamma \yields \rforme{i} A \type} \and
%\inferrule*[left=$\surd$-intro]{\Gamma, \ctxlocke{i} \yields a : A}{\Gamma \yields \rintroe{i} a : \rforme{i} A} \and
%\inferrule*[left=$\surd$-elim]{\Gamma, i : \Tiny \yields r : \rforme{i} A}{\Gamma \yields \relim{i.r} : A[\sublock{}{i}]} \\
%\relim{i.\rintroe{i} a} \defeq a[\sublock{}{i}] \and r \defeq \rintroe{i}{\relim{j. \varkeye{j}{i} r}} \text{ for } r : \rforme{i} A
%\end{mathpar}
%This is probably bad: $\rintroe{i} a$ is a term that looks like it binds a fresh variable $i$, but that is not actually a variable you can use anywhere other than in the subscript of $\key$.

%\section{Contraction}
%In some settings, like BCH cubes~\cite{bch:cubes}, there is a semicartesian monoidal product $\otimes$, and the interval $\mathbb{I}$ is tiny not for $\to$, but $\lolli$. Interestingly, the existing \rulen{$\rformu$-elim} rule would be derivable, because of first precomposing with the map $\Gamma \otimes I \to \Gamma \times I$. We also do not need to worry about the unit, because it is only ever used with a context literally of the form $(\Gamma \otimes i : \Tiny), \ctxlock{L}$.
%
%And so the only place an affineness restriction can come into play is in the counit/variable rule, where we build in a term of $\Tiny$.
%\mvrnote{come back to this?}

%There are a couple of alternative ideas for how variables could work, but each has implications for the admissible rules.
%\begin{itemize}
%\item \textbf{Keep Some Context.}
%
%
%\item \textbf{Keep Full Context.} A more powerful option would be to keep the same context for each $t_i$.
%\begin{mathpar}
%\inferrule*[left=var?]{
%\Gamma, x : A, \Gamma' \yields t_i : \Tiny \text{ for } \lockn{L}_i \in \mathsf{locks}(\Gamma')
%}{\Gamma, x : A, \Gamma' \yields \varkeye{\lockn{L}_n}{t_n} \dots \varkeye{\lockn{L}_1}{t_1} x : \admkeye{\lockn{L}_n}{t_n} \dots \admkeye{\lockn{L}_1}{t_1} A} \and
%\end{mathpar}
%This is building in some kind of contraction for $\Tiny$. The downside is that calculating $\admkey{L}{t} a$ is weirder: we would need to remember the $\ctxlock{K}$ that we go under in the term $a$, and then adjust $\admkey{L}{t}$ so that $t$ is still a valid term. With this variable rule, we define:
%\begin{align*}
%\admkeye{\lockn{L}}{t}  \left(\varkeye{\lockn{K}_n}{s_n} \dots \varkeye{\lockn{K}_{i+1}}{s_{i+1}} \varkeye{\lockn{K}_i}{s_i} \dots \varkeye{\lockn{K}_1}{s_1} x\right) &:\defeq \varkeye{\lockn{K}_n}{s_n} \dots \varkeye{\lockn{K}_{i+1}}{s_{i+1}} \varkeye{\lockn{L}}{t'}  \varkeye{\lockn{K}_i}{\admkeye{\lockn{L}}{t'} s_i} \dots \varkeye{\lockn{K}_1}{\admkeye{\lockn{L}}{t'} s_1} x \\
%& \quad \text{where } t' :\defeq \admkeye{\lockn{K}_n}{s_n} \dots \admkeye{\lockn{K}_{i+1}}{s_{i+1}} t
%\end{align*}
%and then the map $\rformu A \to \rformu \rformu A$ is definable. Maybe it makes sense to order the keys the other way around in this style.
%
%So let's try that:
%\begin{mathpar}
%\inferrule*[left=var?]{
%\Gamma, x : A, \Gamma' \yields t_i : \Tiny \text{ for } \lockn{L}_i \in \mathsf{locks}(\Gamma')
%}{\Gamma, x : A, \Gamma' \yields \varkeye{\lockn{L}_1}{t_1} \dots \varkeye{\lockn{L}_n}{t_n} x : \admkeye{\lockn{L}_1}{t_1} \dots \admkeye{\lockn{L}_n}{t_n} A} \and
%\end{mathpar}
%and
%\begin{align*}
%\admkeye{\lockn{L}}{t} \left(\varkeye{\lockn{K}_1}{s_1} \dots \varkeye{\lockn{K}_i}{s_i}\varkeye{\lockn{K}_{i+1}}{s_{i+1}} \dots \varkeye{\lockn{K}_n}{s_n} x\right) &:\defeq \varkeye{\lockn{K}_1}{\admkeye{\lockn{L}}{t'} s_1} \dots \varkeye{\lockn{K}_i}{\admkeye{\lockn{L}}{t'} s_i} \varkeye{\lockn{L}}{t'} \varkeye{\lockn{K}_{i+1}}{s_{i+1}} \dots \varkeye{\lockn{K}_n}{s_n} a \\
%& \quad \text{where } t' :\defeq \admkeye{\lockn{K}_{i+1}}{s_{i+1}} \dots \admkeye{\lockn{K}_n}{s_n} t
%\end{align*}
%And the lock
%\begin{align*}
%(\varkey{L}{t} \varkeye{\lockn{K}_n}{s_n} \dots \varkeye{\lockn{K}_1}{s_1} x)[\sublock{L}{i}] &:\defeq (\varkeye{\lockn{K}_n}{s_n} \dots \varkeye{\lockn{K}_1}{s_1} x)[t[\sublock{L}{i}]/i] \\
%(\varkey{L'}{t'} \varkeye{\lockn{K}_n}{s_n} \dots \varkeye{\lockn{K}_1}{s_1} x)[\sublock{L}{i}] &:\defeq \admkey{L'}{t'[\sublock{L}{i}]}(\varkeye{\lockn{K}_n}{s_n} \dots \varkeye{\lockn{K}_1}{s_1} x)[\sublock{L}{i}] \\
%x[\sublock{L}{i}] &:\defeq x
%%(\admkey{L}{t} c) [a/x] &:\defeq \admkey{L}{t[a/x]} c[a/x] \\
%%(\varkey{L}{t} c)[\sublock{L}{i}] &:\defeq c[t[\sublock{L}{i}]/i] %\\
%%(\admkey{K}{t} c)[\sublock{L}{i}] &:\defeq \admkey{K}{t[\sublock{L}{i}]} c[\sublock{L}{i}] &&\lockn{L} \not\defeq \lockn{K}
%\end{align*}
%
%\item \textbf{Fully General Counit.} If you build a substitution for $i : \Tiny$ into
%\begin{mathpar}
%\inferrule*[left=counit?,fraction={-{\,-\,}-}]{\Gamma,\Gamma' \yields a : A}{\Gamma, \ctxlock{L}, i : \Tiny, \admkey{L}{t}\Gamma' \yields \admkey{L}{t} a : \admkey{L}{i} A}
%\end{mathpar}
%then the fully general counit should be
%\begin{mathpar}
%\inferrule*[left=counit?,fraction={-{\,-\,}-}]{\Gamma,\Gamma' \yields a : A \and \Gamma, \ctxlock{L}, \admkey{L}{t}\Gamma' \yields t : \Tiny}{\Gamma, \ctxlock{L}, \admkey{L}{t}\Gamma' \yields \admkey{L}{t} a : \admkey{L}{t} A}
%\end{mathpar}
%which looks a bit psycho, with $t$ appearing in its own context.
%
%What if instead, we use some kind of context clearing operation.
%\begin{mathpar}
%\inferrule*[left=counit?,fraction={-{\,-\,}-}]{\Gamma,\Gamma' \yields a : A \and \Gamma, \ctxlock{L}, \Gamma'\setminus \Gamma \yields t : \Tiny}{\Gamma, \ctxlock{L}, \admkey{L}{t}\Gamma' \yields \admkey{L}{t} a : \admkey{L}{t} A}
%\end{mathpar}
%
%The variable rule should match this: for a single lock,
%\begin{mathpar}
%\inferrule*[left=var?,fraction={-{\,-\,}-}]{\Gamma_1,x : A,\Gamma_2, \ctxlock{L}, \admkey{L}{t}\Gamma' \yields t : \Tiny}{\Gamma_1,x : A,\Gamma_2, \ctxlock{L}, \admkey{L}{t}\Gamma' \yields \varkey{L}{t} x : \admkey{L}{t} A}
%\end{mathpar}
%and there would be some complicated n-ary version. This would also solve the contraction problem, but the form of the conclusion doesn't look stable under substitution absent some crazy trick.
%\end{itemize}
%
%
%\section{Pushouts}
%Because $(\Tiny \to -)$ is now a left adjoint, it should preserve e.g. pushouts. Let $(f,g) : A \leftarrow S \to B$ and consider the pushout $A +_S B$. First, supposing the inputs are closed, Prop~\ref{prop:closed-adj},
%\begin{align*}
%&\rform{L} (\Tiny \to A +_S B) \to C)\\
%&\equiv (A +_S B \to \rform{L} C) \\
%&\equiv \sm{h : A \to \rform{L} C}{k : B \to \rform{L} C} \prd{s : S} h(f(s)) = k(g(s)) \\
%&\equiv \sm{h : \rform{L} (\Tiny \to A) \to C}{k : \rform{L} (\Tiny \to B) \to C} \prd{s : S} \rintro{L}{\rget{h}(\lambda j.(\varkey{L}{j} f)(\varkey{L}{j} s))} =\rintro{L}{\rget{k}(\lambda j.(\varkey{L}{j} g)(\varkey{L}{j} s))} \\
%&\equiv \sm{h : \rform{L} (\Tiny \to A) \to C}{k : \rform{L} (\Tiny \to B) \to C} \prd{s : S} \rform{L}{\left(\rget{h}(\lambda j.(\varkey{L}{j} f)(\varkey{L}{j} s)) = \rget{k}(\lambda j.(\varkey{L}{j} g)(\varkey{L}{j} s))\right)} \\
%&\equiv \sm{h : \rform{L} (\Tiny \to A) \to C}{k : \rform{L} (\Tiny \to B) \to C} \rform{L}{\left(\prd{p : \Tiny \to S} \rget{h}(\lambda j.(\varkey{L}{j} f)(p(j))) = \rget{k}(\lambda j.(\varkey{L}{j} g)(p(j)))\right)} ? \\
%&\equiv \rform{L} \left( \sm{h :(\Tiny \to A) \to C}{k : (\Tiny \to B) \to C} \prd{p : \Tiny \to S} h(\lambda j.(\varkey{L}{j} f)(p(j))) = k(\lambda j.(\varkey{L}{j} g)(p(j)))\right) \\
%&\equiv \rform{L} \left((\Tiny \to A) +_{\Tiny \to S} (\Tiny \to B) \to C\right)
%\end{align*}
%which is what we hoped.
%\begin{align*}
%&\rform{L} ((\prd{t:\Tiny} \varkey{L}{t} (A +_S B)) \to \rget{C})\\
%&\equiv (A +_S B \to \rform{L} \rget{C}) \\
%&\equiv \sm{h : A \to \rform{L} \rget{C}}{k : B \to \rform{L} \rget{C}} \prd{s : S} h(f(s)) = k(g(s)) \\
%&\equiv \sm{h : \rform{L} ((\prd{t:\Tiny} \varkey{L}{t} A) \to \rget{C})
%}{k : \rform{L} ((\prd{t:\Tiny} \varkey{L}{t} B) \to \rget{C})
%} \prd{s : S} h(f(s)) = k(g(s)) \\
%\end{align*}
\fi

\section{Total Substitutions}
\begin{mathpar}
\inferrule*{~}{\Gamma \yields \cdot : \cdot} \and
\inferrule*{\Gamma \yields \theta : \Delta \and \Gamma \yields a : A[\theta]}{\Gamma \yields \theta, a : \Delta, a} \\
\inferrule*{\Gamma, i : \Tiny \yields \theta : \Delta}{\Gamma \yields (\theta,i./\lockn{L}) : \Delta,\ctxlock{L}} \and \
\inferrule*[fraction={-{\,-\,}-}]{\Gamma \yields \theta : \Delta}{\Gamma, \ctxlock{L}, l : \Tiny \yields (\admkey{L}{l} \theta) : \Delta}
\end{mathpar}
With the last one (hopefully) admissible. Then we can define functoriality, the unit and swap:
\begin{mathpar}
\inferrule*[fraction={-{\,-\,}-}]{\Gamma \yields \theta : \Delta}{\Gamma,\ctxlock{L} \yields \theta,\ctxlock{L} : \Delta,\ctxlock{L}} \and
\inferrule*[fraction={-{\,-\,}-}]{~}{\Gamma \yields (\id_\Gamma, \sublock{L}{i}) : \Gamma, i : \Tiny, \ctxlock{L}} \and
\inferrule*[fraction={-{\,-\,}-}]{~}{\Gamma,\ctxlock{L},\ctxlock{K} \yields \id_\Gamma,\mathrm{swap}_{\lockn{L},\lockn{K}} : \Gamma,\ctxlock{K},\ctxlock{L}}
\end{mathpar}
by
\begin{align*}
\theta,\ctxlock{L} &:\defeq (\admkey{L}{i} \theta),i./\lockn{L} \\
\id_\Gamma,\sublock{L}{i} &:\defeq \id_\Gamma, j/i, j./\lockn{L} \\
\id_\Gamma,\mathrm{swap}_{\lockn{L},\lockn{K}} &:\defeq (\admkey{K}{l}((\admkey{L}{k}\id_\Gamma),k./\lockn{K})), l./\lockn{L}
\end{align*}

Couple of concerns: First, how is $\admkey{L}{l}$ defined on $\theta, k./\lockn{K}$? There we have $\Gamma, k : \Tiny \yields \theta : \Delta$ and have to end up with $\Gamma, \ctxlock{L}, l : \Tiny \yields ? : \Delta$. We need to be able to only apply $\admkey{L}{l}$ to a prefix of the context:
\begin{mathpar}
\inferrule*[fraction={-{\,-\,}-}]{\Gamma, \Gamma' \yields \theta : \Delta}{\Gamma, \ctxlock{L}, l : \Tiny, \admkey{L}{l}\Gamma' \yields \admkey{L}{l} \theta : \Delta}
\end{mathpar}
If we successfully make this rule admissible, then we don't have to worry about substituting into it.

Second, does substitution by $\theta,i./\lockn{L}$ actually work? The only place it could go wrong is the variable rule, because \rulen{var} is the only rule with a $\ctxlock{L}$ in the conclusion. Substitution into a variable is defined by
\begin{align*}
(\varkeye{\lockn{L}_n}{t_n} \dots \varkeye{\lockn{L}_1}{t_1} x)[\theta, i./\lockn{L}_n, \theta'] &:\defeq (\varkeye{\lockn{L}_{n-1}}{t_{n-1}} \dots \varkeye{\lockn{L}_1}{t_1} x)[\theta][t[\theta, i./\lockn{L}_n, \theta']/i] \\
&\defeq (\varkeye{\lockn{L}_{n-1}}{t_{n-1}} \dots \varkeye{\lockn{L}_1}{t_1} x)[\theta \circ (\id_\Delta, t[\theta, i./\lockn{L}_n, \theta']/i)]
\end{align*}
and eventually $x[\theta, a/x, \theta'] :\defeq a$ once all the keys are gone.


\section{The Bug}

The variable rule is not closed under substitution, if the superscripts on the keys get complicated:
\begin{alignat*}{2}
x : A, \ctxlock{L}, B : \univ, \ctxlock{K}, f : \varkey{K}{0} B \to \Tiny, b &:  \varkey{K}{0} B, t : \Tiny &&\yields \varkey{K}{t} \varkey{L}{t} x : A \\
x : A, \ctxlock{L}, B : \univ, \ctxlock{K}, f : \varkey{K}{0} B \to \Tiny, b &:  \varkey{K}{0} B &&\yields \varkey{K}{f(b)} \varkey{L}{f(b)} x : A
\end{alignat*}
but the second term is not well formed, because the $f$ and $b$ get cleared after the first key and so can't be used in the second. So we either need some kind of affineness restriction, or we need to go `fully cartesian' instead of this half-way option.

Here's an idea: We build in as much cartesian-ness as possible,
\begin{mathpar}
\inferrule*[left=var]{
\Gamma, x : A, \Gamma' \yields t_i : \Tiny \text{ for } \lockn{L}_i \in \mathsf{locks}(\Gamma')
}{\Gamma, x : A, \Gamma' \yields \varkeye{\lockn{L}_n}{t_n} \dots \varkeye{\lockn{L}_1}{t_1} x : \admkeye{\lockn{L}_n}{t_n} \dots \admkeye{\lockn{L}_1}{t_1} A}
\end{mathpar}
\begin{mathpar}
\inferrule*[left=counit,fraction={-{\,-\,}-}]{\Gamma, \Gamma'' \yields a : A \and \Gamma, \ctxlock{L}, \Gamma' \yields t : \Tiny}{\Gamma, \ctxlock{L}, \Gamma', \admkey{L}{t}\Gamma'' \yields \admkey{L}{t} a : \admkey{L}{t} A}
\end{mathpar}

This is annoying, because when $\admkey{L}{t}$ reaches a variable, it has to recur into all the superscripts of the existing keys, rather than stopping as the outermost key.

Maybe we can use some sugar to make it manageable:
\begin{mathpar}
\inferrule*[left=counit,fraction={-{\,-\,}-}]{\Gamma, \ctxlock{L}^{t}, \Gamma' \yields a : A \and \Gamma, \ctxlock{L}, \Gamma' \yields t : \Tiny}{\Gamma, \ctxlock{L}, \admkey{L}{t}\Gamma' \yields \admkey{L}{t} a : \admkey{L}{t} A}
\end{mathpar}
\begin{mathpar}
\inferrule*[left=var]{~ \ctxlock{L}^\varnothing \notin \Gamma'}{\Gamma, x : A, \Gamma' \yields x : A}
\end{mathpar}
and then we try to build the former into the latter. But then how do we handle a lock being opened more than once?

\begin{mathpar}
\inferrule*[left=counit?,fraction={-{\,-\,}-}]{\Gamma \yields a : A \and \Gamma, \ctxlock{L}, \Gamma' \yields t : \Tiny \and \lock \notin \Gamma'}{\Gamma, \ctxlock{L}, \Gamma' \yields \admkey{L}{t} a : \admkey{L}{t} A}
\end{mathpar}
but we will need a generalised version of this, for going under binders in $a : A$. The actual counit rule is then
\begin{mathpar}
\inferrule*[left=counit,fraction={-{\,-\,}-}]{\Gamma, \Gamma'' \yields a : A \and \Gamma, \ctxlock{L}, \Gamma' \yields t : \Tiny}{\Gamma, \ctxlock{L}, \Gamma', \admkey{L}{t}\Gamma'' \yields \admkey{L}{t} a : \admkey{L}{t} A}
\end{mathpar}


Notation idea: write keys like
\begin{align*}
  \key(t/\lockn{L}, s/\lockn{K}) x
\end{align*}
and write the unit substitution as
\begin{align*}
  \judge[i/\lockn{L}]
\end{align*}
so you get
\begin{align*}
  \left(\key(t/\lockn{L}, s/\lockn{K}) i\right)[i/\lockn{L}]
  &\defeq   i[t/i] \defeq t
\end{align*}
or in that case maybe it should be postfix
\begin{align*}
  \left(i \key[t/\lockn{L}, s/\lockn{K}] \right)[i/\lockn{L}]
  \defeq i [t/i]
\end{align*}

%\section{Combined With Cohesion??}
%Heaven help us

\printbibliography

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
