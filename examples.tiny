let the : (A : U) -> A -> A
    := \A a. a;

let const : (A B : U) -> A -> B -> A
          := \A B x y. x;

let comp : (A : U) (B : U) (C : U)
    -> (B -> C)
    -> (A -> B)    
    -> (A -> C)    
  := \A B C f g x. f (g x);

let iterated : T -> v/ (T -> T)
    := \i. rintro (\j. i[i[i[i[j]]]]);

let extract : (A : v/ U)
    -> (v/ relim i. A[i]) 
    -> relim i. A
  := \A x. relim i. x;

let duplicate : (A : v/ U)
    -> (v/ relim i. A[i]) 
    -> (v/ v/ relim i. A[i, i]) 
  := \A r. rintro rintro relim i. r[i, i];

let iterated : T -> v/ (T -> T)
  := \i. rintro (\j. i[i[i[i[j]]]]);

let func : (A : v/ U) (B : v/ U)
    -> (v/ ((relim i. A[i]) -> (relim i. B[i]))) 
    -> (v/ (relim i. A[i])) -> (v/ relim i. B[i])
  := \A B f r. rintro (relim i. f[i]) (relim i. r[i]);

let eta : (A : U)
    -> A -> v/ ((i : T) -> A[i])
  := \A x. rintro \i. x[i];

let epsilon : (B : T -> v/ U)
    -> ((t : T) -> v/ relim j. B[j] t[j])
    -> relim j. B j
  := \B f. relim i. f(i);

let conj_left_nondep : (A : U) (B : v/ U)
    -> (v/ ((t : T) -> A[t]) -> relim i. B[i])
    -> (A -> v/ relim i. B[i])
  := \A B g a. rintro (relim i. g[i]) (\j. a[j]);

let conj_right_nondep : (A : U) (B : v/ U)
    -> (A -> v/ relim i. B[i])
    -> (v/ ((t : T) -> A[t]) -> relim i. B[i])
  := \A B f. rintro \h. relim k. f[k] (h k);

let conj_left : (A : U) (B : A -> v/ U)
    -> (v/ (h : (t : T) -> A[t]) -> relim i. B[i] (h i))
    -> ((a : A) -> v/ relim i. B[i] a[i])
  := \A B g a. rintro (relim i. g[i]) (\j. a[j]);

let conj_right : (A : U) (B : A -> v/ U)
    -> ((a : A) -> v/ relim i. B[i] a[i])
    -> (v/ ((h : (t : T) -> A[t]) -> relim i. B[i] (h i)))
  := \A B f. rintro \h. relim k. f[k] (h k);

conj_right
